{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"ISCC - Codec & Algorithms # iscc-core is a Python library that implements the core algorithms of the ISCC ( International Standard Content Code ) What is an ISCC # The ISCC is a similarity preserving identifier for digital media assets. ISCCs are generated algorithmically from digital content, just like cryptographic hashes. However, instead of using a single cryptographic hash function to identify data only, the ISCC uses various algorithms to create a composite identifier that exhibits similarity-preserving properties (soft hash). The component-based structure of the ISCC identifies content at multiple levels of abstraction. Each component is self-describing, modular, and can be used separately or with others to aid in various content identification tasks. The algorithmic design supports content deduplication, database synchronization, indexing, integrity verification, timestamping, versioning, data provenance, similarity clustering, anomaly detection, usage tracking, allocation of royalties, fact-checking and general digital asset management use-cases. What is iscc-core # iscc-core is the python based library of the core algorithms to create standard-compliant ISCC codes. It also serves as a reference for porting ISCC to other programming languages. Tip This is a low level reference implementation. iscc-core does not support content/metadata detection, extraction or preprocessing. For easy generation of ISCC codes see: iscc-cli | ISCC Architecture # ISCC MainTypes # Idx Slug Bits Purpose 0 META 0000 Match on metadata similarity 1 SEMANTIC 0001 Match on semantic content similarity 2 CONTENT 0010 Match on perceptual content similarity 3 DATA 0011 Match on data similarity 4 INSTANCE 0100 Match on data identity 5 ISCC 0101 Composite of two or more components with common header 6 ID 0110 Short unique identifier bound to ISCC, timestamp, pubkey Installation # Use the package manager pip to install iscc-core . pip install iscc-core Quick Start # import iscc_core meta_code = iscc_core . gen_meta_code ( name = \"ISCC Test Document!\" ) print ( f \"Meta-Code: { meta_code . iscc } \" ) print ( f \"Structure: { meta_code . code_obj . explain } \\n \" ) # Extract text from file with open ( \"demo.txt\" , \"rt\" , encoding = \"utf-8\" ) as stream : text = stream . read () text_code = iscc_core . gen_text_code_v0 ( text ) print ( f \"Text-Code: { text_code . iscc } \" ) print ( f \"Structure: { text_code . code_obj . explain } \\n \" ) # Process raw bytes of textfile with open ( \"demo.txt\" , \"rb\" ) as stream : data_code = iscc_core . gen_data_code ( stream ) print ( f \"Data-Code: { data_code . iscc } \" ) print ( f \"Structure: { data_code . code_obj . explain } \\n \" ) stream . seek ( 0 ) instance_code = iscc_core . gen_instance_code ( stream ) print ( f \"Instance-Code: { instance_code . iscc } \" ) print ( f \"Structure: { instance_code . code_obj . explain } \\n \" ) iscc_code = iscc_core . gen_iscc_code ( ( meta_code . iscc , text_code . iscc , data_code . iscc , instance_code . iscc ) ) print ( f \"ISCC-CODE: { iscc_code . iscc } \" ) print ( f \"Structure: { iscc_code . code_obj . explain } \" ) print ( f \"Multiformat: { iscc_code . code_obj . mf_base32 } \\n \" ) iscc_id = iscc_core . gen_iscc_id ( chain = 1 , iscc_code = iscc_code . iscc , uc = 7 ) print ( f \"ISCC-ID: { iscc_id . iscc } \" ) print ( f \"Structure: { iscc_id . code_obj . explain } \" ) print ( f \"Multiformat: { iscc_id . code_obj . mf_base32 } \" ) The output of this example is as follows: Meta-Code: ISCC:AAA3MGR7CSJ3O3D3 Structure: META-NONE-V0-64-b61a3f1493b76c7b Text-Code: ISCC:EAAUIQCMQJO757BF Structure: CONTENT-TEXT-V0-64-44404c825dfefc25 Data-Code: ISCC:GAAZ5SQ47ZQ34A3V Structure: DATA-NONE-V0-64-9eca1cfe61be0375 Instance-Code: ISCC:IAASQF7FY2TLVFRC Structure: INSTANCE-NONE-V0-64-2817e5c6a6ba9622 ISCC-CODE: ISCC:KAC3MGR7CSJ3O3D3IRAEZAS5736CLHWKDT7GDPQDOUUBPZOGU25JMIQ Structure: ISCC-TEXT-V0-MCDI-b61a3f1493b76c7b44404c825dfefc259eca1cfe61be03752817e5c6a6ba9622 Multiformat: bzqavabnwdi7rje5xnr5uiqcmqjo757bft3fbz7tbxybxkkax4xdknouwei ISCC-ID: ISCC:MEASBFSKDSLFDPTMA4 Structure: ID-BITCOIN-V0-72-20964a1c9651be6c-7 Multiformat: bzqawcajaszfbzfsrxzwao Documentation # https://core.iscc.codes Project Status # ISCC is in the process of being standardized within ISO/TC 46/SC 9 . Maintainers # @titusz Contributing # Pull requests are welcome. For significant changes, please open an issue first to discuss your plans. Please make sure to update tests as appropriate. You may also want join our developer chat on Telegram at https://t.me/iscc_dev . Changelog # 0.2.0 - Unreleased # Code cleanup 0.1.9 - 2021-12-17 # Added warning on non-standard options Added multiformats support Added uri representation Removed redundant cdc_avg_chunk_size option Updated codec format documentation 0.1.8 - 2021-12-12 # Added conformance tests for all top level functions Added conformance tests to source dir Added conformance module with selftest function Changed gen_image_code to accept normalized pixels instead of stream Changed opts to core_opts Removed image pre-processing and Pillow dependency Fixed readability of conformance tests Fixed soft_hash_video_v0 to accept non-tuple sequences Updated example code 0.1.7 - 2021-12-09 # Add dotenv for enviroment based configuration Cleanup package toplevel imports Return schema objects for iscc_code and iscc_id Exclude unset and none values from result dicts Add support for multiple code combinations for ISCC-CODE Add support for ISCC-ID based on singular Instance-Code Add initial conformance test system 0.1.6 - 2021-11-29 # Show counter for ISCC-ID in Code.explain 0.1.5 - 2021-11-28 # Fix documentation Change metahash creation logic Refactor models Add Content-Code-Mixed Add ISCC-ID Refactor compose to gen_iscc_code Refactor models to schema 0.1.4 - 2021-11-17 # Simplified options Optimize video WTA-hash for use with 64-bit granular features 0.1.3 - 2021-11-15 # Try to compile Cython/C accelerator modules when installing via pip Simplify soft_hash api return values Add .code() method to InstanceHasher, DataHasher Remove granular fingerprint calculation Add more top-level imports 0.1.2 - 2021-11-14 # Export more functions to toplevel Return schema driven objects from ISCC code generators. 0.1.1 - 2021-11-14 # Fix packaging problems 0.1.0 - 2021-11-13 # Initial release","title":"Overview"},{"location":"#iscc-codec-algorithms","text":"iscc-core is a Python library that implements the core algorithms of the ISCC ( International Standard Content Code )","title":"ISCC - Codec &amp; Algorithms"},{"location":"#what-is-an-iscc","text":"The ISCC is a similarity preserving identifier for digital media assets. ISCCs are generated algorithmically from digital content, just like cryptographic hashes. However, instead of using a single cryptographic hash function to identify data only, the ISCC uses various algorithms to create a composite identifier that exhibits similarity-preserving properties (soft hash). The component-based structure of the ISCC identifies content at multiple levels of abstraction. Each component is self-describing, modular, and can be used separately or with others to aid in various content identification tasks. The algorithmic design supports content deduplication, database synchronization, indexing, integrity verification, timestamping, versioning, data provenance, similarity clustering, anomaly detection, usage tracking, allocation of royalties, fact-checking and general digital asset management use-cases.","title":"What is an ISCC"},{"location":"#what-is-iscc-core","text":"iscc-core is the python based library of the core algorithms to create standard-compliant ISCC codes. It also serves as a reference for porting ISCC to other programming languages. Tip This is a low level reference implementation. iscc-core does not support content/metadata detection, extraction or preprocessing. For easy generation of ISCC codes see: iscc-cli |","title":"What is iscc-core"},{"location":"#iscc-architecture","text":"","title":"ISCC Architecture"},{"location":"#iscc-maintypes","text":"Idx Slug Bits Purpose 0 META 0000 Match on metadata similarity 1 SEMANTIC 0001 Match on semantic content similarity 2 CONTENT 0010 Match on perceptual content similarity 3 DATA 0011 Match on data similarity 4 INSTANCE 0100 Match on data identity 5 ISCC 0101 Composite of two or more components with common header 6 ID 0110 Short unique identifier bound to ISCC, timestamp, pubkey","title":"ISCC MainTypes"},{"location":"#installation","text":"Use the package manager pip to install iscc-core . pip install iscc-core","title":"Installation"},{"location":"#quick-start","text":"import iscc_core meta_code = iscc_core . gen_meta_code ( name = \"ISCC Test Document!\" ) print ( f \"Meta-Code: { meta_code . iscc } \" ) print ( f \"Structure: { meta_code . code_obj . explain } \\n \" ) # Extract text from file with open ( \"demo.txt\" , \"rt\" , encoding = \"utf-8\" ) as stream : text = stream . read () text_code = iscc_core . gen_text_code_v0 ( text ) print ( f \"Text-Code: { text_code . iscc } \" ) print ( f \"Structure: { text_code . code_obj . explain } \\n \" ) # Process raw bytes of textfile with open ( \"demo.txt\" , \"rb\" ) as stream : data_code = iscc_core . gen_data_code ( stream ) print ( f \"Data-Code: { data_code . iscc } \" ) print ( f \"Structure: { data_code . code_obj . explain } \\n \" ) stream . seek ( 0 ) instance_code = iscc_core . gen_instance_code ( stream ) print ( f \"Instance-Code: { instance_code . iscc } \" ) print ( f \"Structure: { instance_code . code_obj . explain } \\n \" ) iscc_code = iscc_core . gen_iscc_code ( ( meta_code . iscc , text_code . iscc , data_code . iscc , instance_code . iscc ) ) print ( f \"ISCC-CODE: { iscc_code . iscc } \" ) print ( f \"Structure: { iscc_code . code_obj . explain } \" ) print ( f \"Multiformat: { iscc_code . code_obj . mf_base32 } \\n \" ) iscc_id = iscc_core . gen_iscc_id ( chain = 1 , iscc_code = iscc_code . iscc , uc = 7 ) print ( f \"ISCC-ID: { iscc_id . iscc } \" ) print ( f \"Structure: { iscc_id . code_obj . explain } \" ) print ( f \"Multiformat: { iscc_id . code_obj . mf_base32 } \" ) The output of this example is as follows: Meta-Code: ISCC:AAA3MGR7CSJ3O3D3 Structure: META-NONE-V0-64-b61a3f1493b76c7b Text-Code: ISCC:EAAUIQCMQJO757BF Structure: CONTENT-TEXT-V0-64-44404c825dfefc25 Data-Code: ISCC:GAAZ5SQ47ZQ34A3V Structure: DATA-NONE-V0-64-9eca1cfe61be0375 Instance-Code: ISCC:IAASQF7FY2TLVFRC Structure: INSTANCE-NONE-V0-64-2817e5c6a6ba9622 ISCC-CODE: ISCC:KAC3MGR7CSJ3O3D3IRAEZAS5736CLHWKDT7GDPQDOUUBPZOGU25JMIQ Structure: ISCC-TEXT-V0-MCDI-b61a3f1493b76c7b44404c825dfefc259eca1cfe61be03752817e5c6a6ba9622 Multiformat: bzqavabnwdi7rje5xnr5uiqcmqjo757bft3fbz7tbxybxkkax4xdknouwei ISCC-ID: ISCC:MEASBFSKDSLFDPTMA4 Structure: ID-BITCOIN-V0-72-20964a1c9651be6c-7 Multiformat: bzqawcajaszfbzfsrxzwao","title":"Quick Start"},{"location":"#documentation","text":"https://core.iscc.codes","title":"Documentation"},{"location":"#project-status","text":"ISCC is in the process of being standardized within ISO/TC 46/SC 9 .","title":"Project Status"},{"location":"#maintainers","text":"@titusz","title":"Maintainers"},{"location":"#contributing","text":"Pull requests are welcome. For significant changes, please open an issue first to discuss your plans. Please make sure to update tests as appropriate. You may also want join our developer chat on Telegram at https://t.me/iscc_dev .","title":"Contributing"},{"location":"#changelog","text":"","title":"Changelog"},{"location":"#020-unreleased","text":"Code cleanup","title":"0.2.0 - Unreleased"},{"location":"#019-2021-12-17","text":"Added warning on non-standard options Added multiformats support Added uri representation Removed redundant cdc_avg_chunk_size option Updated codec format documentation","title":"0.1.9 - 2021-12-17"},{"location":"#018-2021-12-12","text":"Added conformance tests for all top level functions Added conformance tests to source dir Added conformance module with selftest function Changed gen_image_code to accept normalized pixels instead of stream Changed opts to core_opts Removed image pre-processing and Pillow dependency Fixed readability of conformance tests Fixed soft_hash_video_v0 to accept non-tuple sequences Updated example code","title":"0.1.8 - 2021-12-12"},{"location":"#017-2021-12-09","text":"Add dotenv for enviroment based configuration Cleanup package toplevel imports Return schema objects for iscc_code and iscc_id Exclude unset and none values from result dicts Add support for multiple code combinations for ISCC-CODE Add support for ISCC-ID based on singular Instance-Code Add initial conformance test system","title":"0.1.7 - 2021-12-09"},{"location":"#016-2021-11-29","text":"Show counter for ISCC-ID in Code.explain","title":"0.1.6 - 2021-11-29"},{"location":"#015-2021-11-28","text":"Fix documentation Change metahash creation logic Refactor models Add Content-Code-Mixed Add ISCC-ID Refactor compose to gen_iscc_code Refactor models to schema","title":"0.1.5 - 2021-11-28"},{"location":"#014-2021-11-17","text":"Simplified options Optimize video WTA-hash for use with 64-bit granular features","title":"0.1.4 - 2021-11-17"},{"location":"#013-2021-11-15","text":"Try to compile Cython/C accelerator modules when installing via pip Simplify soft_hash api return values Add .code() method to InstanceHasher, DataHasher Remove granular fingerprint calculation Add more top-level imports","title":"0.1.3 - 2021-11-15"},{"location":"#012-2021-11-14","text":"Export more functions to toplevel Return schema driven objects from ISCC code generators.","title":"0.1.2 - 2021-11-14"},{"location":"#011-2021-11-14","text":"Fix packaging problems","title":"0.1.1 - 2021-11-14"},{"location":"#010-2021-11-13","text":"Initial release","title":"0.1.0 - 2021-11-13"},{"location":"conformance/","text":"ISCC - Conformance Testing # An application that claims ISCC conformance MUST pass all core functions from the ISCC conformance test suite. The test suite is available as JSON data on Github . Test data is structured as follows: { \"<function_name>\" : { \"<test_name>\" : { \"inputs\" : [ \"<value1>\" , \"<value2>\" ], \"outputs\" : [ \"value1>\" , \"<value2>\" ] } } } Inputs that are expected to be raw byte streams are embedded as HEX encoded strings in JSON and prefixed with stream: to support automated decoding during implementation testing. Example Byte outputs in JSON test data: \"gen_data_code_v0\" : { \"test_0000_two_bytes_64\" : { \"inputs\" : [ \"stream:ff00\" , 64 ], \"outputs\" : { \"iscc\" : \"GAAXL2XYM5BQIAZ3\" } }, ... generate_tests () # Yield tuples of test data. Returns: Type Description Union[Generat,[Tuple[str, Callable, List[Any], List[Any]]]] Tuple with testdata (test_name, func_obj, inputs, outputs) selftest () # Run conformance tests. Returns: Type Description bool whether all tests passed","title":"Conformance"},{"location":"conformance/#iscc-conformance-testing","text":"An application that claims ISCC conformance MUST pass all core functions from the ISCC conformance test suite. The test suite is available as JSON data on Github . Test data is structured as follows: { \"<function_name>\" : { \"<test_name>\" : { \"inputs\" : [ \"<value1>\" , \"<value2>\" ], \"outputs\" : [ \"value1>\" , \"<value2>\" ] } } } Inputs that are expected to be raw byte streams are embedded as HEX encoded strings in JSON and prefixed with stream: to support automated decoding during implementation testing. Example Byte outputs in JSON test data: \"gen_data_code_v0\" : { \"test_0000_two_bytes_64\" : { \"inputs\" : [ \"stream:ff00\" , 64 ], \"outputs\" : { \"iscc\" : \"GAAXL2XYM5BQIAZ3\" } }, ...","title":"ISCC - Conformance Testing"},{"location":"conformance/#iscc_core.conformance.generate_tests","text":"Yield tuples of test data. Returns: Type Description Union[Generat,[Tuple[str, Callable, List[Any], List[Any]]]] Tuple with testdata (test_name, func_obj, inputs, outputs)","title":"generate_tests()"},{"location":"conformance/#iscc_core.conformance.selftest","text":"Run conformance tests. Returns: Type Description bool whether all tests passed","title":"selftest()"},{"location":"iscc_code/","text":"ISCC-CODE # A multi-component identifier for digital media assets. An ISCC-CODE is generated from the concatenation of the digests of the following four components together with a single common header: Meta-Code - Encodes metadata similarity Content-Code - Encodes syntactic/perceptual similarity Data-Code - Encodes raw bitstream similarity Instance-Code - Data checksum The following combinations of components are possible: Meta, Content, Data, Instance (256-bit / 64-bit per component) Content, Data, Instance (192-bit / 64-bit per component) Data, Instance (256 or 128 bit / 64 or 128-bit per component) gen_iscc_code ( codes ) # Combine multiple ISCC components to a composite ISCC-CODE with a common header using the latest standard algorithm. Parameters: Name Type Description Default codes Sequence[str] A valid sequence of singluar ISCC codes. required Returns: Type Description ISCC An ISCC object with ISCC-CODE gen_iscc_code_v0 ( codes ) # Combine multiple ISCC-UNITS to an ISCC-CODE with a common header using algorithm v0. Parameters: Name Type Description Default codes Sequence[str] A valid sequence of singluar ISCC-UNITS. required Returns: Type Description ISCC An ISCC object with ISCC-CODE","title":"ISCC-CODE"},{"location":"iscc_code/#iscc-code","text":"A multi-component identifier for digital media assets. An ISCC-CODE is generated from the concatenation of the digests of the following four components together with a single common header: Meta-Code - Encodes metadata similarity Content-Code - Encodes syntactic/perceptual similarity Data-Code - Encodes raw bitstream similarity Instance-Code - Data checksum The following combinations of components are possible: Meta, Content, Data, Instance (256-bit / 64-bit per component) Content, Data, Instance (192-bit / 64-bit per component) Data, Instance (256 or 128 bit / 64 or 128-bit per component)","title":"ISCC-CODE"},{"location":"iscc_code/#iscc_core.iscc_code.gen_iscc_code","text":"Combine multiple ISCC components to a composite ISCC-CODE with a common header using the latest standard algorithm. Parameters: Name Type Description Default codes Sequence[str] A valid sequence of singluar ISCC codes. required Returns: Type Description ISCC An ISCC object with ISCC-CODE","title":"gen_iscc_code()"},{"location":"iscc_code/#iscc_core.iscc_code.gen_iscc_code_v0","text":"Combine multiple ISCC-UNITS to an ISCC-CODE with a common header using algorithm v0. Parameters: Name Type Description Default codes Sequence[str] A valid sequence of singluar ISCC-UNITS. required Returns: Type Description ISCC An ISCC object with ISCC-CODE","title":"gen_iscc_code_v0()"},{"location":"iscc_id/","text":"ISCC-ID # A decentralized short identifier for digital assets. The ISCC-ID is generated from a similarity-hash of the components of an ISCC-CODE . Its SubType designates the blockchain from which the ISCC-ID was minted. The similarity-hash is always at least 64-bits and optionally suffixed with a uvarint endcoded uniqueness counter . The uniqueness counter is added and incremented only if the mint colides with a pre-existing ISCC-ID minted from the same blockchain from a different ISCC-CODE or from an identical ISCC-CODE registered by a different signatory. gen_iscc_id ( chain , iscc_code , uc = 0 ) # Generate ISCC-ID from ISCC-CODE with the latest standard algorithm. Parameters: Name Type Description Default chain int Chain-ID of blockchain from which the ISCC-ID is minted. required iscc_code str The ISCC-CODE from which to mint the ISCC-ID. required uc int Uniqueness counter of ISCC-ID. 0 Returns: Type Description ISCC ISCC object with an ISCC-ID gen_iscc_id_v0 ( chain_id , iscc_code , uc = 0 ) # Generate an ISCC-ID from an ISCC-CODE with uniqueness counter 'uc' with algorithm v0. Parameters: Name Type Description Default chain_id int Chain-ID of blockchain from which the ISCC-ID is minted. required iscc_code str The ISCC-CODE from which to mint the ISCC-ID. required uc int Uniqueness counter for ISCC-ID. 0 Returns: Type Description ISCC ISCC object with an ISCC-ID soft_hash_iscc_id_v0 ( iscc_code , uc = 0 ) # Calculate ISCC-ID hash digest from ISCC-CODE digest with algorithm v0. Parameters: Name Type Description Default iscc_code str ISCC-CODE required uc int Uniqueness counter for ISCC-ID. 0 Returns: Type Description bytes Digest for ISCC-ID without header but including uniqueness counter. incr_iscc_id ( iscc_id ) # Increment uniqueness counter of an ISCC-ID with latest standard algorithm. Parameters: Name Type Description Default iscc_id str Base32-encoded ISCC-ID. required Returns: Type Description str Base32-encoded ISCC-ID with counter incremented by one. incr_iscc_id_v0 ( iscc_id ) # Increment uniqueness counter of an ISCC-ID with algorithm v0. Parameters: Name Type Description Default iscc_id str Base32-encoded ISCC-ID. required Returns: Type Description str Base32-encoded ISCC-ID with counter incremented by one.","title":"ISCC-ID"},{"location":"iscc_id/#iscc-id","text":"A decentralized short identifier for digital assets. The ISCC-ID is generated from a similarity-hash of the components of an ISCC-CODE . Its SubType designates the blockchain from which the ISCC-ID was minted. The similarity-hash is always at least 64-bits and optionally suffixed with a uvarint endcoded uniqueness counter . The uniqueness counter is added and incremented only if the mint colides with a pre-existing ISCC-ID minted from the same blockchain from a different ISCC-CODE or from an identical ISCC-CODE registered by a different signatory.","title":"ISCC-ID"},{"location":"iscc_id/#iscc_core.iscc_id.gen_iscc_id","text":"Generate ISCC-ID from ISCC-CODE with the latest standard algorithm. Parameters: Name Type Description Default chain int Chain-ID of blockchain from which the ISCC-ID is minted. required iscc_code str The ISCC-CODE from which to mint the ISCC-ID. required uc int Uniqueness counter of ISCC-ID. 0 Returns: Type Description ISCC ISCC object with an ISCC-ID","title":"gen_iscc_id()"},{"location":"iscc_id/#iscc_core.iscc_id.gen_iscc_id_v0","text":"Generate an ISCC-ID from an ISCC-CODE with uniqueness counter 'uc' with algorithm v0. Parameters: Name Type Description Default chain_id int Chain-ID of blockchain from which the ISCC-ID is minted. required iscc_code str The ISCC-CODE from which to mint the ISCC-ID. required uc int Uniqueness counter for ISCC-ID. 0 Returns: Type Description ISCC ISCC object with an ISCC-ID","title":"gen_iscc_id_v0()"},{"location":"iscc_id/#iscc_core.iscc_id.soft_hash_iscc_id_v0","text":"Calculate ISCC-ID hash digest from ISCC-CODE digest with algorithm v0. Parameters: Name Type Description Default iscc_code str ISCC-CODE required uc int Uniqueness counter for ISCC-ID. 0 Returns: Type Description bytes Digest for ISCC-ID without header but including uniqueness counter.","title":"soft_hash_iscc_id_v0()"},{"location":"iscc_id/#iscc_core.iscc_id.incr_iscc_id","text":"Increment uniqueness counter of an ISCC-ID with latest standard algorithm. Parameters: Name Type Description Default iscc_id str Base32-encoded ISCC-ID. required Returns: Type Description str Base32-encoded ISCC-ID with counter incremented by one.","title":"incr_iscc_id()"},{"location":"iscc_id/#iscc_core.iscc_id.incr_iscc_id_v0","text":"Increment uniqueness counter of an ISCC-ID with algorithm v0. Parameters: Name Type Description Default iscc_id str Base32-encoded ISCC-ID. required Returns: Type Description str Base32-encoded ISCC-ID with counter incremented by one.","title":"incr_iscc_id_v0()"},{"location":"algorithms/cdc/","text":"ISCC - Content Defined Chunking # Compatible with fastcdc data_chunks ( data , utf32 , avg_chunk_size = 1024 ) # A generator that yields data-dependent chunks for data . Usage Example: for chunk in data_chunks ( data ): hash ( chunk ) Parameters: Name Type Description Default data bytes Raw data for variable sized chunking. required utf32 bool If true assume we are chunking text that is utf32 encoded. required avg_chunk_size int Target chunk size in number of bytes. 1024 Returns: Type Description Union[Generat,[bytes]] A generator that yields data chunks of variable sizes. Source code in iscc_core\\cdc.py def data_chunks ( data , utf32 , avg_chunk_size = core_opts . data_avg_chunk_size ): # type: (Data, bool, int) -> Generator[bytes, None, None] \"\"\" A generator that yields data-dependent chunks for `data`. Usage Example: ```python for chunk in data_chunks(data): hash(chunk) ``` :param bytes data: Raw data for variable sized chunking. :param bool utf32: If true assume we are chunking text that is utf32 encoded. :param int avg_chunk_size: Target chunk size in number of bytes. :return: A generator that yields data chunks of variable sizes. :rtype: Generator[bytes] \"\"\" stream = io . BytesIO ( data ) buffer = stream . read ( core_opts . io_read_size ) if not buffer : yield b \"\" mi , ma , cs , mask_s , mask_l = get_params ( avg_chunk_size ) buffer = memoryview ( buffer ) while buffer : if len ( buffer ) <= ma : buffer = memoryview ( bytes ( buffer ) + stream . read ( core_opts . io_read_size )) cut_point = cdc_offset ( buffer , mi , ma , cs , mask_s , mask_l ) # Make sure cut points are at 4-byte aligned for utf32 encoded text if utf32 : cut_point -= cut_point % 4 yield bytes ( buffer [: cut_point ]) buffer = buffer [ cut_point :] cdc_offset ( buffer , mi , ma , cs , mask_s , mask_l ) # Find breakpoint offset for a given buffer. Parameters: Name Type Description Default buffer Data The data to be chunked. required mi int Minimum chunk size. required ma int Maximung chunk size. required cs int Center size. required mask_s int Small mask. required mask_l int Large mask. required Returns: Type Description int Offset of dynamic cutpoint in number of bytes. Source code in iscc_core\\cdc.py def cdc_offset ( buffer , mi , ma , cs , mask_s , mask_l ): # type: (Data, int, int, int, int, int) -> int \"\"\" Find breakpoint offset for a given buffer. :param Data buffer: The data to be chunked. :param int mi: Minimum chunk size. :param int ma: Maximung chunk size. :param int cs: Center size. :param int mask_s: Small mask. :param int mask_l: Large mask. :return: Offset of dynamic cutpoint in number of bytes. :rtype: int \"\"\" pattern = 0 i = mi size = len ( buffer ) barrier = min ( cs , size ) while i < barrier : pattern = ( pattern >> 1 ) + core_opts . cdc_gear [ buffer [ i ]] if not pattern & mask_s : return i + 1 i += 1 barrier = min ( ma , size ) while i < barrier : pattern = ( pattern >> 1 ) + core_opts . cdc_gear [ buffer [ i ]] if not pattern & mask_l : return i + 1 i += 1 return i get_params ( avg_size : int ) -> tuple # Calculate CDC parameters Parameters: Name Type Description Default avg_size int Target average size of chunks in number of bytes. required Returns: Type Description tuple Tuple of (min_size, max_size, center_size, mask_s, mask_l). Source code in iscc_core\\cdc.py def get_params ( avg_size : int ) -> tuple : \"\"\" Calculate CDC parameters :param int avg_size: Target average size of chunks in number of bytes. :returns: Tuple of (min_size, max_size, center_size, mask_s, mask_l). \"\"\" ceil_div = lambda x , y : ( x + y - 1 ) // y mask = lambda b : 2 ** b - 1 min_size = avg_size // 4 max_size = avg_size * 8 offset = min_size + ceil_div ( min_size , 2 ) center_size = avg_size - offset bits = round ( log2 ( avg_size )) mask_s = mask ( bits + 1 ) mask_l = mask ( bits - 1 ) return min_size , max_size , center_size , mask_s , mask_l","title":"CDC"},{"location":"algorithms/cdc/#iscc-content-defined-chunking","text":"Compatible with fastcdc","title":"ISCC - Content Defined Chunking"},{"location":"algorithms/cdc/#iscc_core.cdc.data_chunks","text":"A generator that yields data-dependent chunks for data . Usage Example: for chunk in data_chunks ( data ): hash ( chunk ) Parameters: Name Type Description Default data bytes Raw data for variable sized chunking. required utf32 bool If true assume we are chunking text that is utf32 encoded. required avg_chunk_size int Target chunk size in number of bytes. 1024 Returns: Type Description Union[Generat,[bytes]] A generator that yields data chunks of variable sizes. Source code in iscc_core\\cdc.py def data_chunks ( data , utf32 , avg_chunk_size = core_opts . data_avg_chunk_size ): # type: (Data, bool, int) -> Generator[bytes, None, None] \"\"\" A generator that yields data-dependent chunks for `data`. Usage Example: ```python for chunk in data_chunks(data): hash(chunk) ``` :param bytes data: Raw data for variable sized chunking. :param bool utf32: If true assume we are chunking text that is utf32 encoded. :param int avg_chunk_size: Target chunk size in number of bytes. :return: A generator that yields data chunks of variable sizes. :rtype: Generator[bytes] \"\"\" stream = io . BytesIO ( data ) buffer = stream . read ( core_opts . io_read_size ) if not buffer : yield b \"\" mi , ma , cs , mask_s , mask_l = get_params ( avg_chunk_size ) buffer = memoryview ( buffer ) while buffer : if len ( buffer ) <= ma : buffer = memoryview ( bytes ( buffer ) + stream . read ( core_opts . io_read_size )) cut_point = cdc_offset ( buffer , mi , ma , cs , mask_s , mask_l ) # Make sure cut points are at 4-byte aligned for utf32 encoded text if utf32 : cut_point -= cut_point % 4 yield bytes ( buffer [: cut_point ]) buffer = buffer [ cut_point :]","title":"data_chunks()"},{"location":"algorithms/cdc/#iscc_core.cdc.cdc_offset","text":"Find breakpoint offset for a given buffer. Parameters: Name Type Description Default buffer Data The data to be chunked. required mi int Minimum chunk size. required ma int Maximung chunk size. required cs int Center size. required mask_s int Small mask. required mask_l int Large mask. required Returns: Type Description int Offset of dynamic cutpoint in number of bytes. Source code in iscc_core\\cdc.py def cdc_offset ( buffer , mi , ma , cs , mask_s , mask_l ): # type: (Data, int, int, int, int, int) -> int \"\"\" Find breakpoint offset for a given buffer. :param Data buffer: The data to be chunked. :param int mi: Minimum chunk size. :param int ma: Maximung chunk size. :param int cs: Center size. :param int mask_s: Small mask. :param int mask_l: Large mask. :return: Offset of dynamic cutpoint in number of bytes. :rtype: int \"\"\" pattern = 0 i = mi size = len ( buffer ) barrier = min ( cs , size ) while i < barrier : pattern = ( pattern >> 1 ) + core_opts . cdc_gear [ buffer [ i ]] if not pattern & mask_s : return i + 1 i += 1 barrier = min ( ma , size ) while i < barrier : pattern = ( pattern >> 1 ) + core_opts . cdc_gear [ buffer [ i ]] if not pattern & mask_l : return i + 1 i += 1 return i","title":"cdc_offset()"},{"location":"algorithms/cdc/#iscc_core.cdc.get_params","text":"Calculate CDC parameters Parameters: Name Type Description Default avg_size int Target average size of chunks in number of bytes. required Returns: Type Description tuple Tuple of (min_size, max_size, center_size, mask_s, mask_l). Source code in iscc_core\\cdc.py def get_params ( avg_size : int ) -> tuple : \"\"\" Calculate CDC parameters :param int avg_size: Target average size of chunks in number of bytes. :returns: Tuple of (min_size, max_size, center_size, mask_s, mask_l). \"\"\" ceil_div = lambda x , y : ( x + y - 1 ) // y mask = lambda b : 2 ** b - 1 min_size = avg_size // 4 max_size = avg_size * 8 offset = min_size + ceil_div ( min_size , 2 ) center_size = avg_size - offset bits = round ( log2 ( avg_size )) mask_s = mask ( bits + 1 ) mask_l = mask ( bits - 1 ) return min_size , max_size , center_size , mask_s , mask_l","title":"get_params()"},{"location":"algorithms/dct/","text":"ISCC - Discrete Cosine Transform # dct ( v ) # Discrete cosine transform. See: nayuki.io . Parameters: Name Type Description Default v Sequence[float] Input vector for DCT calculation. required Returns: Type Description List DCT Transformed vector. Source code in iscc_core\\dct.py def dct ( v ): # type: (Sequence[float]) -> List \"\"\" Discrete cosine transform. See: [nayuki.io](https://www.nayuki.io/page/fast-discrete-cosine-transform-algorithms). :param Sequence[float] v: Input vector for DCT calculation. :return: DCT Transformed vector. :rtype: List \"\"\" n = len ( v ) if n == 1 : return list ( v ) elif n == 0 or n % 2 != 0 : raise ValueError () else : half = n // 2 alpha = [( v [ i ] + v [ - ( i + 1 )]) for i in range ( half )] beta = [ ( v [ i ] - v [ - ( i + 1 )]) / ( math . cos (( i + 0.5 ) * math . pi / n ) * 2.0 ) for i in range ( half ) ] alpha = dct ( alpha ) beta = dct ( beta ) result = [] for i in range ( half - 1 ): result . append ( alpha [ i ]) result . append ( beta [ i ] + beta [ i + 1 ]) result . append ( alpha [ - 1 ]) result . append ( beta [ - 1 ]) return result","title":"DCT"},{"location":"algorithms/dct/#iscc-discrete-cosine-transform","text":"","title":"ISCC - Discrete Cosine Transform"},{"location":"algorithms/dct/#iscc_core.dct.dct","text":"Discrete cosine transform. See: nayuki.io . Parameters: Name Type Description Default v Sequence[float] Input vector for DCT calculation. required Returns: Type Description List DCT Transformed vector. Source code in iscc_core\\dct.py def dct ( v ): # type: (Sequence[float]) -> List \"\"\" Discrete cosine transform. See: [nayuki.io](https://www.nayuki.io/page/fast-discrete-cosine-transform-algorithms). :param Sequence[float] v: Input vector for DCT calculation. :return: DCT Transformed vector. :rtype: List \"\"\" n = len ( v ) if n == 1 : return list ( v ) elif n == 0 or n % 2 != 0 : raise ValueError () else : half = n // 2 alpha = [( v [ i ] + v [ - ( i + 1 )]) for i in range ( half )] beta = [ ( v [ i ] - v [ - ( i + 1 )]) / ( math . cos (( i + 0.5 ) * math . pi / n ) * 2.0 ) for i in range ( half ) ] alpha = dct ( alpha ) beta = dct ( beta ) result = [] for i in range ( half - 1 ): result . append ( alpha [ i ]) result . append ( beta [ i ] + beta [ i + 1 ]) result . append ( alpha [ - 1 ]) result . append ( beta [ - 1 ]) return result","title":"dct()"},{"location":"algorithms/minhash/","text":"ISCC - Minhash # minhash ( features ) # Calculate a 64 dimensional minhash integer vector. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description List[int] Minhash vector Source code in iscc_core\\minhash.py def minhash ( features ): # type: (List[int]) -> List[int] \"\"\" Calculate a 64 dimensional minhash integer vector. :param List[int] features: List of integer features :return: Minhash vector :rtype: List[int] \"\"\" return [ min ([((( a * f + b ) & MAXI64 ) % MPRIME ) & MAXH for f in features ]) for a , b in zip ( MPA , MPB ) ] minhash_64 ( features ) # Create 64-bit minimum hash digest. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description bytes 64-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def minhash_64 ( features ): # type: (List[int]) -> bytes \"\"\" Create 64-bit minimum hash digest. :param List[int] features: List of integer features :return: 64-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" return compress ( minhash ( features ), 1 ) minhash_256 ( features ) # Create 256-bit minimum hash digest. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description bytes 256-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def minhash_256 ( features ): # type: (List[int]) -> bytes \"\"\" Create 256-bit minimum hash digest. :param List[int] features: List of integer features :return: 256-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" return compress ( minhash ( features ), 4 ) compress ( mhash , lsb = 4 ) # Compress minhash vector to byte hash-digest. Concatenates lsb number of least significant bits from each integer in mhash . For example an mhash with 64 integers and lsb=4 will produce a 256-bit summary of the minhash vector. Parameters: Name Type Description Default mhash List[int] List of minhash integer features required lsb int Number of the least significant bits to retain 4 Returns: Type Description bytes 256-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def compress ( mhash , lsb = 4 ): # type: (List[int], int) -> bytes \"\"\" Compress minhash vector to byte hash-digest. Concatenates `lsb` number of least significant bits from each integer in `mhash`. For example an `mhash` with 64 integers and `lsb=4` will produce a 256-bit summary of the minhash vector. :param List[int] mhash: List of minhash integer features :param int lsb: Number of the least significant bits to retain :return: 256-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" bits : str = \"\" for bitpos in range ( lsb ): for h in mhash : bits += str ( h >> bitpos & 1 ) return int ( bits , 2 ) . to_bytes (( len ( bits ) + 7 ) // 8 , \"big\" )","title":"Minhash"},{"location":"algorithms/minhash/#iscc-minhash","text":"","title":"ISCC - Minhash"},{"location":"algorithms/minhash/#iscc_core.minhash.minhash","text":"Calculate a 64 dimensional minhash integer vector. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description List[int] Minhash vector Source code in iscc_core\\minhash.py def minhash ( features ): # type: (List[int]) -> List[int] \"\"\" Calculate a 64 dimensional minhash integer vector. :param List[int] features: List of integer features :return: Minhash vector :rtype: List[int] \"\"\" return [ min ([((( a * f + b ) & MAXI64 ) % MPRIME ) & MAXH for f in features ]) for a , b in zip ( MPA , MPB ) ]","title":"minhash()"},{"location":"algorithms/minhash/#iscc_core.minhash.minhash_64","text":"Create 64-bit minimum hash digest. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description bytes 64-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def minhash_64 ( features ): # type: (List[int]) -> bytes \"\"\" Create 64-bit minimum hash digest. :param List[int] features: List of integer features :return: 64-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" return compress ( minhash ( features ), 1 )","title":"minhash_64()"},{"location":"algorithms/minhash/#iscc_core.minhash.minhash_256","text":"Create 256-bit minimum hash digest. Parameters: Name Type Description Default features List[int] List of integer features required Returns: Type Description bytes 256-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def minhash_256 ( features ): # type: (List[int]) -> bytes \"\"\" Create 256-bit minimum hash digest. :param List[int] features: List of integer features :return: 256-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" return compress ( minhash ( features ), 4 )","title":"minhash_256()"},{"location":"algorithms/minhash/#iscc_core.minhash.compress","text":"Compress minhash vector to byte hash-digest. Concatenates lsb number of least significant bits from each integer in mhash . For example an mhash with 64 integers and lsb=4 will produce a 256-bit summary of the minhash vector. Parameters: Name Type Description Default mhash List[int] List of minhash integer features required lsb int Number of the least significant bits to retain 4 Returns: Type Description bytes 256-bit binary from the least significant bits of the minhash values Source code in iscc_core\\minhash.py def compress ( mhash , lsb = 4 ): # type: (List[int], int) -> bytes \"\"\" Compress minhash vector to byte hash-digest. Concatenates `lsb` number of least significant bits from each integer in `mhash`. For example an `mhash` with 64 integers and `lsb=4` will produce a 256-bit summary of the minhash vector. :param List[int] mhash: List of minhash integer features :param int lsb: Number of the least significant bits to retain :return: 256-bit binary from the least significant bits of the minhash values :rtype: bytes \"\"\" bits : str = \"\" for bitpos in range ( lsb ): for h in mhash : bits += str ( h >> bitpos & 1 ) return int ( bits , 2 ) . to_bytes (( len ( bits ) + 7 ) // 8 , \"big\" )","title":"compress()"},{"location":"algorithms/simhash/","text":"ISCC - Simhash # similarity_hash ( hash_digests ) # Creates a similarity preserving hash from a sequence of equal sized hash digests. Parameters: Name Type Description Default hash_digests list A sequence of equaly sized byte-hashes. required Returns: Type Description bytes Similarity byte-hash Source code in iscc_core\\simhash.py def similarity_hash ( hash_digests ): # type: (list[bytes]) -> bytes \"\"\" Creates a similarity preserving hash from a sequence of equal sized hash digests. :param list hash_digests: A sequence of equaly sized byte-hashes. :returns: Similarity byte-hash :rtype: bytes \"\"\" n_bytes = len ( hash_digests [ 0 ]) n_bits = n_bytes * 8 vector = [ 0 ] * n_bits for digest in hash_digests : h = int . from_bytes ( digest , \"big\" , signed = False ) for i in range ( n_bits ): vector [ i ] += h & 1 h >>= 1 minfeatures = len ( hash_digests ) * 1.0 / 2 shash = 0 for i in range ( n_bits ): shash |= int ( vector [ i ] >= minfeatures ) << i return shash . to_bytes ( n_bytes , \"big\" , signed = False )","title":"Simhash"},{"location":"algorithms/simhash/#iscc-simhash","text":"","title":"ISCC - Simhash"},{"location":"algorithms/simhash/#iscc_core.simhash.similarity_hash","text":"Creates a similarity preserving hash from a sequence of equal sized hash digests. Parameters: Name Type Description Default hash_digests list A sequence of equaly sized byte-hashes. required Returns: Type Description bytes Similarity byte-hash Source code in iscc_core\\simhash.py def similarity_hash ( hash_digests ): # type: (list[bytes]) -> bytes \"\"\" Creates a similarity preserving hash from a sequence of equal sized hash digests. :param list hash_digests: A sequence of equaly sized byte-hashes. :returns: Similarity byte-hash :rtype: bytes \"\"\" n_bytes = len ( hash_digests [ 0 ]) n_bits = n_bytes * 8 vector = [ 0 ] * n_bits for digest in hash_digests : h = int . from_bytes ( digest , \"big\" , signed = False ) for i in range ( n_bits ): vector [ i ] += h & 1 h >>= 1 minfeatures = len ( hash_digests ) * 1.0 / 2 shash = 0 for i in range ( n_bits ): shash |= int ( vector [ i ] >= minfeatures ) << i return shash . to_bytes ( n_bytes , \"big\" , signed = False )","title":"similarity_hash()"},{"location":"algorithms/wtahash/","text":"ISCC - Winner Takes All Hash # wtahash ( vec : Sequence [ float ], bits ) -> bytes # Calculate WTA Hash for vector with 380 values (MP7 frame signature). Source code in iscc_core\\wtahash.py def wtahash ( vec : Sequence [ float ], bits ) -> bytes : \"\"\"Calculate WTA Hash for vector with 380 values (MP7 frame signature).\"\"\" h = [] for perm in WTA_VIDEO_ID_PERMUTATIONS : v = vec [ perm [ 0 ]], vec [ perm [ 1 ]] h . append ( v . index ( max ( v ))) if len ( h ) == bits : break h = bitarray ( h ) . tobytes () return h","title":"WTAHash"},{"location":"algorithms/wtahash/#iscc-winner-takes-all-hash","text":"","title":"ISCC - Winner Takes All Hash"},{"location":"algorithms/wtahash/#iscc_core.wtahash.wtahash","text":"Calculate WTA Hash for vector with 380 values (MP7 frame signature). Source code in iscc_core\\wtahash.py def wtahash ( vec : Sequence [ float ], bits ) -> bytes : \"\"\"Calculate WTA Hash for vector with 380 values (MP7 frame signature).\"\"\" h = [] for perm in WTA_VIDEO_ID_PERMUTATIONS : v = vec [ perm [ 0 ]], vec [ perm [ 1 ]] h . append ( v . index ( max ( v ))) if len ( h ) == bits : break h = bitarray ( h ) . tobytes () return h","title":"wtahash()"},{"location":"codec/codec/","text":"ISCC - Codec # This module implements encoding, decoding and transcoding functions of ISCC Codec Overview # Code Types # MT - MainTypes # Uint Symbol Bits Purpose 0 META 0000 Match on metadata similarity 1 SEMANTIC 0001 Match on semantic content similarity 2 CONTENT 0010 Match on perceptual content similarity 3 DATA 0011 Match on data similarity 4 INSTANCE 0100 Match on data identity 5 ISCC 0101 Composite of two or more components with common header 6 ID 0110 Short unique identifier bound to ISCC, timestamp, pubkey ST - SubTypes # Uint Symbol Bits Purpose 0 NONE 0000 For MainTypes that do not specify SubTypes ST_CC # SubTypes for MT.CONTENT Uint Symbol Bits Purpose 0 TEXT 0000 Match on syntactic text similarity 1 IMAGE 0001 Match on perceptual image similarity 2 AUDIO 0010 Match on audio chroma similarity 3 VIDEO 0011 Match on perceptual similarity 4 MIXED 0100 Match on similarity of content codes ST_ISCC # SubTypes for MT.ISCC Uint Symbol Bits Purpose 0 TEXT 0000 Composite ISCC inlcuding Text-Code 1 IMAGE 0001 Composite ISCC inlcuding Image-Code 2 AUDIO 0010 Composite ISCC inlcuding Audio-Code 3 VIDEO 0011 Composite ISCC inlcuding Video-Code 4 MIXED 0100 Composite ISCC inlcuding Mixed-Code 5 SUM 0101 Composite ISCC inlcuding only Data- and Instance-Code ST_ID # SubTypes for MT.ID Uint Symbol Bits Purpose 0 PRIVATE 0000 ISCC-ID minted via private repository (not unique) 1 BITCOIN 0001 ISCC-ID minted via Bitcoin mainchain 2 ETHEREUM 0010 ISCC-ID minted via Ethereum mainchain VS - Version # Code Version Uint Symbol Bits Purpose 0 V0 0000 Initial Version of Code without breaking changes LN - Length # Valid lengths for hash-digests. Codec Functions # encode_component ( mtype , stype , version , bit_length , digest ) # Encode an ISCC component inlcuding header and body with standard base32 encoding. Note The length value must be the length in number of bits for the component. If digest has more bits than specified by length it wil be truncated. Parameters: Name Type Description Default mtype MainType Maintype of component (0-6) required stype SubType SubType of component depending on MainType (0-5) required version Version Version of component algorithm (0). required bit_length length Length of component in number of bits (multiple of 32) required digest bytes The hash digest of the component. required Returns: Type Description str Base32 encoded component code. Source code in iscc_core\\codec.py def encode_component ( mtype , stype , version , bit_length , digest ): # type: (MainType, SubType, Version, Length, bytes) -> str \"\"\" Encode an ISCC component inlcuding header and body with standard base32 encoding. !!! note The `length` value must be the **length in number of bits** for the component. If `digest` has more bits than specified by `length` it wil be truncated. :param MainType mtype: Maintype of component (0-6) :param SubType stype: SubType of component depending on MainType (0-5) :param Version version: Version of component algorithm (0). :param length bit_length: Length of component in number of bits (multiple of 32) :param bytes digest: The hash digest of the component. :return: Base32 encoded component code. :rtype: str \"\"\" if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE , MT . ID ): encoded_length = encode_length ( mtype , bit_length ) elif mtype == MT . ISCC : raise ValueError ( f \" { mtype } is not a unit\" ) else : raise ValueError ( f \"Illegal MainType { mtype } \" ) nbytes = bit_length // 8 header = write_header ( mtype , stype , version , encoded_length ) body = digest [: nbytes ] component_code = encode_base32 ( header + body ) return component_code write_header ( mtype , stype , version = 0 , length = 1 ) # Encodes header values with nibble-sized (4-bit) variable-length encoding. The result is minimum 2 and maximum 8 bytes long. If the final count of nibbles is uneven it is padded with 4-bit 0000 at the end. Warning The length value must be encoded beforhand because its semantics depend on the MainType (see encode_length function). Parameters: Name Type Description Default mtype MainType MainType of component. required stype SubType SubType of component. required version Version Version of component algorithm. 0 length Length length value of component (1 means 64-bits for standard units) 1 Returns: Type Description bytes Varnibble stream encoded ISCC header as bytes. Source code in iscc_core\\codec.py def write_header ( mtype , stype , version = 0 , length = 1 ): # type: (MainType, SubType, Version, Length) -> bytes \"\"\" Encodes header values with nibble-sized (4-bit) variable-length encoding. The result is minimum 2 and maximum 8 bytes long. If the final count of nibbles is uneven it is padded with 4-bit `0000` at the end. !!! warning The length value must be encoded beforhand because its semantics depend on the MainType (see `encode_length` function). :param MainType mtype: MainType of component. :param SubType stype: SubType of component. :param Version version: Version of component algorithm. :param Length length: length value of component (1 means 64-bits for standard units) :return: Varnibble stream encoded ISCC header as bytes. :rtype: bytes \"\"\" # TODO verify that all header params and there combination is valid header = bitarray () for n in ( mtype , stype , version , length ): header += write_varnibble ( n ) # Append zero-padding if required (right side, least significant bits). header . fill () return header . tobytes () write_varnibble ( n ) # Writes integer to variable length sequence of 4-bit chunks. Variable-length encoding scheme: prefix bits nibbles data bits unsigned range 0 1 3 0 - 7 10 2 6 8 - 71 110 3 9 72 - 583 1110 4 12 584 - 4679 Parameters: Name Type Description Default n int Positive integer to be encoded as varnibble (0-4679) required Returns: Type Description bitarray Varnibble encoded integera Source code in iscc_core\\codec.py def write_varnibble ( n ): # type: (int) -> bitarray \"\"\" Writes integer to variable length sequence of 4-bit chunks. Variable-length encoding scheme: ------------------------------------------------------ | prefix bits | nibbles | data bits | unsigned range | | ----------- | ------- | --------- | -------------- | | 0 | 1 | 3 | 0 - 7 | | 10 | 2 | 6 | 8 - 71 | | 110 | 3 | 9 | 72 - 583 | | 1110 | 4 | 12 | 584 - 4679 | :param int n: Positive integer to be encoded as varnibble (0-4679) :return: Varnibble encoded integera :rtype: bitarray \"\"\" if 0 <= n < 8 : return int2ba ( n , length = 4 ) elif 8 <= n < 72 : return bitarray ( \"10\" ) + int2ba ( n - 8 , length = 6 ) elif 72 <= n < 584 : return bitarray ( \"110\" ) + int2ba ( n - 72 , length = 9 ) elif 584 <= n < 4680 : return bitarray ( \"1110\" ) + int2ba ( n - 584 , length = 12 ) else : raise ValueError ( \"Value must be between 0 and 4679\" ) read_header ( data ) # Decodes varnibble encoded header and returns it together with tail data . Tail data is included to enable decoding of sequential ISCCs. The returned tail data must be truncated to decode_length(r[0], r[3]) bits to recover the actual hash-bytes. Parameters: Name Type Description Default data bytes ISCC bytes required Returns: Type Description IsccTuple (MainType, SubType, Version, length, TailData) Source code in iscc_core\\codec.py def read_header ( data ): # type: (bytes) -> IsccTuple \"\"\" Decodes varnibble encoded header and returns it together with `tail data`. Tail data is included to enable decoding of sequential ISCCs. The returned tail data must be truncated to decode_length(r[0], r[3]) bits to recover the actual hash-bytes. :param bytes data: ISCC bytes :return: (MainType, SubType, Version, length, TailData) :rtype: IsccTuple \"\"\" result = [] ba = bitarray () ba . frombytes ( data ) data = ba for _ in range ( 4 ): value , data = read_varnibble ( data ) result . append ( value ) # TODO: validate correctness of decoded data. # Strip 4-bit padding if required if len ( data ) % 8 and data [: 4 ] == bitarray ( \"0000\" ): data = data [ 4 :] result . append ( data . tobytes ()) return tuple ( result ) read_varnibble ( b ) # Reads first varnibble, returns its integer value and remaining bits. Parameters: Name Type Description Default b bitarray Array of header bits required Returns: Type Description Tuple[int, bitarray] A tuple of the integer value of first varnible and the remaining bits. Source code in iscc_core\\codec.py def read_varnibble ( b ): # type: (bitarray) -> Tuple[int, bitarray] \"\"\"Reads first varnibble, returns its integer value and remaining bits. :param bitarray b: Array of header bits :return: A tuple of the integer value of first varnible and the remaining bits. :rtype: Tuple[int, bitarray] \"\"\" bits = len ( b ) if bits >= 4 and b [ 0 ] == 0 : return ba2int ( b [: 4 ]), b [ 4 :] if bits >= 8 and b [ 1 ] == 0 : return ba2int ( b [ 2 : 8 ]) + 8 , b [ 8 :] if bits >= 12 and b [ 2 ] == 0 : return ba2int ( b [ 3 : 12 ]) + 72 , b [ 12 :] if bits >= 16 and b [ 3 ] == 0 : return ba2int ( b [ 4 : 16 ]) + 584 , b [ 16 :] raise ValueError ( \"Invalid bitarray\" ) encode_units ( units ) # Encodes a combination of ISCC units to an integer between 0-7 to be used as length value for the final encoding of MT.ISCC Parameters: Name Type Description Default units Tuple A tuple of a MainType combination (can be empty) required Returns: Type Description int Integer value to be used as length-value for header encoding Source code in iscc_core\\codec.py def encode_units ( units ): # type: (Tuple[MT, ...]) -> int \"\"\" Encodes a combination of ISCC units to an integer between 0-7 to be used as length value for the final encoding of MT.ISCC :param Tuple units: A tuple of a MainType combination (can be empty) :return: Integer value to be used as length-value for header encoding :rtype: int \"\"\" return UNITS . index ( units ) decode_units ( unit_id ) # Decodes an ISCC header length value that has been encoded with a unit_id to an ordered tuple of MainTypes. Source code in iscc_core\\codec.py def decode_units ( unit_id ): # type: (int) -> Tuple[MT, ...] \"\"\" Decodes an ISCC header length value that has been encoded with a unit_id to an ordered tuple of MainTypes. \"\"\" units = sorted ( UNITS [ unit_id ]) return tuple ( MT ( u ) for u in units ) encode_length ( mtype , length ) # Encode length to integer value for header encoding. The length value has MainType-specific semantics: For MainTypes META , SEMANTIC , CONTENT , DATA , INSTANCE : Length means number of bits for the body. Length is encoded as the multiple of 32-bit chunks (0 being 32bits) Examples: 32 -> 0, 64 -> 1, 96 -> 2 ... For MainType ISCC : MainTypes `DATA` and `INSTANCE` are mandatory for ISCC-CODEs, all others are optional. Length means the composition of optional 64-bit components included in the ISCC composite. Examples: No optional components -> 0000 -> 0 CONTENT -> 0001 -> 1 SEMANTIC -> 0010 -> 2 SEMANTIC, CONTENT -> 0011 -> 3 META -> 0100 -> 4 META, CONTENT -> 0101 -> 5 ... For MainType ID : Lengths means number the number of bits for the body including the counter Length is encoded as number of bytes of the counter (64-bit body is implicit) Examples: 64 -> 0 (No counter) 72 -> 1 (One byte counter) 80 -> 2 (Two byte counter) ... Parameters: Name Type Description Default mtype MainType The MainType for which to encode the length value. required length Length The length expressed according to the semantics of the type required Returns: Type Description int The length value encoded as integer for use with write_header. Source code in iscc_core\\codec.py def encode_length ( mtype , length ): # type: (MainType, Length) -> int \"\"\" Encode length to integer value for header encoding. The `length` value has MainType-specific semantics: For MainTypes `META`, `SEMANTIC`, `CONTENT`, `DATA`, `INSTANCE`: Length means number of bits for the body. Length is encoded as the multiple of 32-bit chunks (0 being 32bits) Examples: 32 -> 0, 64 -> 1, 96 -> 2 ... For MainType `ISCC`: MainTypes `DATA` and `INSTANCE` are mandatory for ISCC-CODEs, all others are optional. Length means the composition of optional 64-bit components included in the ISCC composite. Examples: No optional components -> 0000 -> 0 CONTENT -> 0001 -> 1 SEMANTIC -> 0010 -> 2 SEMANTIC, CONTENT -> 0011 -> 3 META -> 0100 -> 4 META, CONTENT -> 0101 -> 5 ... For MainType `ID`: Lengths means number the number of bits for the body including the counter Length is encoded as number of bytes of the counter (64-bit body is implicit) Examples: 64 -> 0 (No counter) 72 -> 1 (One byte counter) 80 -> 2 (Two byte counter) ... :param MainType mtype: The MainType for which to encode the length value. :param Length length: The length expressed according to the semantics of the type :return: The length value encoded as integer for use with write_header. :rtype: int \"\"\" error = f \"Invalid length { length } for MainType { mtype } \" # standard case (length field denotes number of 32-bit chunks, 0 being 32-bits) if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE ): if length >= 32 and not length % 32 : return ( length // 32 ) - 1 raise ValueError ( error ) # flag type encoding of included components (pass through as encoded out-of-band) elif mtype == MT . ISCC : if 0 <= length <= 7 : return length raise ValueError ( error ) # counter byte lenght encoding elif mtype == MT . ID : if 64 <= length <= 96 : return ( length - 64 ) // 8 raise ValueError ( error ) else : raise ValueError ( error ) decode_length ( mtype , length ) # Dedoce raw length value from ISCC header to length of digest in number of bits. Decodes a raw header integer value in to its semantically meaningfull value (eg. number of bits) Source code in iscc_core\\codec.py def decode_length ( mtype , length ): # type: (MainType, Length) -> LN \"\"\" Dedoce raw length value from ISCC header to length of digest in number of bits. Decodes a raw header integer value in to its semantically meaningfull value (eg. number of bits) \"\"\" if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE ): return LN (( length + 1 ) * 32 ) elif mtype == MT . ISCC : return LN ( len ( decode_units ( length )) * 64 + 128 ) elif mtype == MT . ID : return LN ( length * 8 + 64 ) else : raise ValueError ( f \"Invalid length { length } for MainType { mtype } \" ) encode_base32 ( data ) # Standard RFC4648 base32 encoding without padding. Source code in iscc_core\\codec.py def encode_base32 ( data ): # type: (bytes) -> str \"\"\" Standard RFC4648 base32 encoding without padding. \"\"\" return b32encode ( data ) . decode ( \"ascii\" ) . rstrip ( \"=\" ) decode_base32 ( code ) # Standard RFC4648 base32 decoding without padding and with casefolding. Source code in iscc_core\\codec.py def decode_base32 ( code ): # type: (str) -> bytes \"\"\" Standard RFC4648 base32 decoding without padding and with casefolding. \"\"\" # python stdlib does not support base32 without padding, so we have to re-pad. cl = len ( code ) pad_length = math . ceil ( cl / 8 ) * 8 - cl return bytes ( b32decode ( code + \"=\" * pad_length , casefold = True )) encode_base64 ( data : bytes ) -> str # Standard RFC4648 base64url encoding without padding. Source code in iscc_core\\codec.py def encode_base64 ( data : bytes ) -> str : \"\"\" Standard RFC4648 base64url encoding without padding. \"\"\" code = urlsafe_b64encode ( data ) . decode ( \"ascii\" ) return code . rstrip ( \"=\" ) decode_base64 ( code : str ) -> bytes # Standard RFC4648 base64url decoding without padding. Source code in iscc_core\\codec.py def decode_base64 ( code : str ) -> bytes : \"\"\" Standard RFC4648 base64url decoding without padding. \"\"\" padding = 4 - ( len ( code ) % 4 ) string = code + ( \"=\" * padding ) return urlsafe_b64decode ( string ) decompose ( iscc_code ) # Decompose an ISCC-CODE or any valid ISCC sequence into a list of ISCC-UNITS. A valid ISCC sequence is a string concatenation of ISCC-UNITS optionally seperated by a hyphen. Source code in iscc_core\\codec.py def decompose ( iscc_code ): # type: (str) -> List[str] \"\"\" Decompose an ISCC-CODE or any valid ISCC sequence into a list of ISCC-UNITS. A valid ISCC sequence is a string concatenation of ISCC-UNITS optionally seperated by a hyphen. \"\"\" iscc_code = clean ( iscc_code ) components = [] raw_code = decode_base32 ( iscc_code ) while raw_code : mt , st , vs , ln , body = read_header ( raw_code ) # standard ISCC-UNIT with tail continuation if mt != MT . ISCC : ln_bits = decode_length ( mt , ln ) code = encode_component ( mt , st , vs , ln_bits , body [: ln_bits // 8 ]) components . append ( code ) raw_code = body [ ln_bits // 8 :] continue # ISCC-CODE main_types = decode_units ( ln ) # rebuild dynamic units (META, SEMANTIC, CONTENT) for idx , mtype in enumerate ( main_types ): stype = ST . NONE if mtype == MT . META else st code = encode_component ( mtype , stype , vs , 64 , body [ idx * 8 :]) components . append ( code ) # rebuild static units (DATA, INSTANCE) data_code = encode_component ( MT . DATA , ST . NONE , vs , 64 , body [ - 16 : - 8 ]) instance_code = encode_component ( MT . INSTANCE , ST . NONE , vs , 64 , body [ - 8 :]) components . extend ([ data_code , instance_code ]) break return components normalize ( iscc_code ) # Normalize an ISCC to its canonical URI form. The canonical form of an ISCC is its shortest base32 encoded representation prefixed with the string ISCC: . Possible valid inputs: MEACB7X7777574L6 ISCC:MEACB7X7777574L6 fcc010001657fe7cafe9791bb iscc:maagztfqttvizpjr Iscc:Maagztfqttvizpjr Info A concatenated sequence of codes will be composed into a single ISCC of MainType MT.ISCC if possible. Example >>> import iscc_core >>> iscc_core . normalize ( \"GAAW2PRCRS5LNVZV-IAAUVACQKXE3V44W\" ) ISCC : KUBW2PRCRS5LNVZVJKAFAVOJXLZZM Parameters: Name Type Description Default iscc_code str Any valid ISCC string required Returns: Type Description str Normalized ISCC Source code in iscc_core\\codec.py def normalize ( iscc_code ): # type: (str) -> str \"\"\" Normalize an ISCC to its canonical URI form. The canonical form of an ISCC is its shortest base32 encoded representation prefixed with the string `ISCC:`. Possible valid inputs: MEACB7X7777574L6 ISCC:MEACB7X7777574L6 fcc010001657fe7cafe9791bb iscc:maagztfqttvizpjr Iscc:Maagztfqttvizpjr !!! info A concatenated sequence of codes will be composed into a single ISCC of MainType `MT.ISCC` if possible. !!! example ``` py >>> import iscc_core >>> iscc_core.normalize(\"GAAW2PRCRS5LNVZV-IAAUVACQKXE3V44W\") ISCC:KUBW2PRCRS5LNVZVJKAFAVOJXLZZM ``` :param str iscc_code: Any valid ISCC string :return: Normalized ISCC :rtype: str \"\"\" from iscc_core.iscc_code import gen_iscc_code_v0 decoders = { MULTIBASE . base16 : bytes . fromhex , # f MULTIBASE . base32 : decode_base32 , # b MULTIBASE . base58btc : base58 . b58decode , # z MULTIBASE . base64url : decode_base64 , # u } # Transcode to base32 if <multibase><multicodec> encoded multibase_prefix = iscc_code [ 0 ] if multibase_prefix in decoders . keys (): decoder = decoders [ multibase_prefix ] decoded = decoder ( iscc_code [ 1 :]) if not decoded . startswith ( Code . mc_prefix ): raise ValueError ( f \"Malformed multiformat codec: { decoded [: 2 ] } \" ) iscc_code = encode_base32 ( decoded [ 2 :]) decomposed = decompose ( iscc_code ) recomposed = gen_iscc_code_v0 ( decomposed ) . iscc if len ( decomposed ) >= 2 else decomposed [ 0 ] return f \"ISCC: { recomposed } \" if not recomposed . startswith ( \"ISCC:\" ) else recomposed validate ( iscc , strict = True ) # Validate that a given string is a strictly well-formed ISCC. A strictly well-formed ISCC is: an ISCC-CODE or ISCC-UNIT encoded with base32 upper without padding has a valid combination of header values is represented in its canonical URI form Parameters: Name Type Description Default iscc str ISCC string required strict bool Raise an exeption if validation fails (default True) True Returns: Type Description bool True if sting is valid else false. (raises ValueError in strict mode) Source code in iscc_core\\codec.py def validate ( iscc , strict = True ): # type: (str) -> bool \"\"\" Validate that a given string is a *strictly well-formed* ISCC. A *strictly well-formed* ISCC is: - an ISCC-CODE or ISCC-UNIT - encoded with base32 upper without padding - has a valid combination of header values - is represented in its canonical URI form :param str iscc: ISCC string :param bool strict: Raise an exeption if validation fails (default True) :return: True if sting is valid else false. (raises ValueError in strict mode) :rtype: bool \"\"\" # Basic regex validation match = re . match ( \"^ISCC:[A-Z2-7]{10,60}$\" , iscc ) if not match : if strict : raise ValueError ( \"ISCC string does not match ^ISCC:[A-Z2-7]{10,60}$\" ) else : return False # Header valid valid_prefixes = { \"CQ\" , \"EQ\" , \"MA\" , \"EE\" , \"KA\" , \"CI\" , \"KU\" , \"CE\" , \"ME\" , \"IA\" , \"MI\" , \"KM\" , \"EI\" , \"KE\" , \"EM\" , \"CM\" , \"KI\" , \"EA\" , \"GA\" , \"AA\" , \"CA\" , \"KQ\" , } cleaned = clean ( iscc ) prefix = cleaned [: 2 ] if prefix not in valid_prefixes : if strict : raise ValueError ( f \"Header starts with invalid sequence { prefix } \" ) else : return False return True clean ( iscc ) # Cleanup ISCC string. Removes leading scheme, dashes, leading/trailing whitespace. Parameters: Name Type Description Default iscc str Any valid ISCC string required Returns: Type Description str Cleaned ISCC string. Source code in iscc_core\\codec.py def clean ( iscc ): # type: (str) -> str \"\"\" Cleanup ISCC string. Removes leading scheme, dashes, leading/trailing whitespace. :param str iscc: Any valid ISCC string :return: Cleaned ISCC string. :rtype: str \"\"\" split = [ part . strip () for part in iscc . strip () . split ( \":\" )] if len ( split ) == 1 : code = split [ 0 ] # remove dashes if not multiformat if code [ 0 ] not in list ( MULTIBASE ): code = code . replace ( \"-\" , \"\" ) return code elif len ( split ) == 2 : scheme , code = split if scheme . lower () != \"iscc\" : raise ValueError ( f \"Invalid scheme: { scheme } \" ) return code . replace ( \"-\" , \"\" ) else : raise ValueError ( f \"Malformed ISCC string: { iscc } \" )","title":"Codec"},{"location":"codec/codec/#iscc-codec","text":"This module implements encoding, decoding and transcoding functions of ISCC","title":"ISCC - Codec"},{"location":"codec/codec/#codec-overview","text":"","title":"Codec Overview"},{"location":"codec/codec/#code-types","text":"","title":"Code Types"},{"location":"codec/codec/#iscc_core.codec.MT--mt-maintypes","text":"Uint Symbol Bits Purpose 0 META 0000 Match on metadata similarity 1 SEMANTIC 0001 Match on semantic content similarity 2 CONTENT 0010 Match on perceptual content similarity 3 DATA 0011 Match on data similarity 4 INSTANCE 0100 Match on data identity 5 ISCC 0101 Composite of two or more components with common header 6 ID 0110 Short unique identifier bound to ISCC, timestamp, pubkey","title":"MT - MainTypes"},{"location":"codec/codec/#iscc_core.codec.ST--st-subtypes","text":"Uint Symbol Bits Purpose 0 NONE 0000 For MainTypes that do not specify SubTypes","title":"ST - SubTypes"},{"location":"codec/codec/#iscc_core.codec.ST_CC--st_cc","text":"SubTypes for MT.CONTENT Uint Symbol Bits Purpose 0 TEXT 0000 Match on syntactic text similarity 1 IMAGE 0001 Match on perceptual image similarity 2 AUDIO 0010 Match on audio chroma similarity 3 VIDEO 0011 Match on perceptual similarity 4 MIXED 0100 Match on similarity of content codes","title":"ST_CC"},{"location":"codec/codec/#iscc_core.codec.ST_ISCC--st_iscc","text":"SubTypes for MT.ISCC Uint Symbol Bits Purpose 0 TEXT 0000 Composite ISCC inlcuding Text-Code 1 IMAGE 0001 Composite ISCC inlcuding Image-Code 2 AUDIO 0010 Composite ISCC inlcuding Audio-Code 3 VIDEO 0011 Composite ISCC inlcuding Video-Code 4 MIXED 0100 Composite ISCC inlcuding Mixed-Code 5 SUM 0101 Composite ISCC inlcuding only Data- and Instance-Code","title":"ST_ISCC"},{"location":"codec/codec/#iscc_core.codec.ST_ID--st_id","text":"SubTypes for MT.ID Uint Symbol Bits Purpose 0 PRIVATE 0000 ISCC-ID minted via private repository (not unique) 1 BITCOIN 0001 ISCC-ID minted via Bitcoin mainchain 2 ETHEREUM 0010 ISCC-ID minted via Ethereum mainchain","title":"ST_ID"},{"location":"codec/codec/#iscc_core.codec.VS--vs-version","text":"Code Version Uint Symbol Bits Purpose 0 V0 0000 Initial Version of Code without breaking changes","title":"VS - Version"},{"location":"codec/codec/#iscc_core.codec.LN--ln-length","text":"Valid lengths for hash-digests.","title":"LN - Length"},{"location":"codec/codec/#codec-functions","text":"","title":"Codec Functions"},{"location":"codec/codec/#iscc_core.codec.encode_component","text":"Encode an ISCC component inlcuding header and body with standard base32 encoding. Note The length value must be the length in number of bits for the component. If digest has more bits than specified by length it wil be truncated. Parameters: Name Type Description Default mtype MainType Maintype of component (0-6) required stype SubType SubType of component depending on MainType (0-5) required version Version Version of component algorithm (0). required bit_length length Length of component in number of bits (multiple of 32) required digest bytes The hash digest of the component. required Returns: Type Description str Base32 encoded component code. Source code in iscc_core\\codec.py def encode_component ( mtype , stype , version , bit_length , digest ): # type: (MainType, SubType, Version, Length, bytes) -> str \"\"\" Encode an ISCC component inlcuding header and body with standard base32 encoding. !!! note The `length` value must be the **length in number of bits** for the component. If `digest` has more bits than specified by `length` it wil be truncated. :param MainType mtype: Maintype of component (0-6) :param SubType stype: SubType of component depending on MainType (0-5) :param Version version: Version of component algorithm (0). :param length bit_length: Length of component in number of bits (multiple of 32) :param bytes digest: The hash digest of the component. :return: Base32 encoded component code. :rtype: str \"\"\" if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE , MT . ID ): encoded_length = encode_length ( mtype , bit_length ) elif mtype == MT . ISCC : raise ValueError ( f \" { mtype } is not a unit\" ) else : raise ValueError ( f \"Illegal MainType { mtype } \" ) nbytes = bit_length // 8 header = write_header ( mtype , stype , version , encoded_length ) body = digest [: nbytes ] component_code = encode_base32 ( header + body ) return component_code","title":"encode_component()"},{"location":"codec/codec/#iscc_core.codec.write_header","text":"Encodes header values with nibble-sized (4-bit) variable-length encoding. The result is minimum 2 and maximum 8 bytes long. If the final count of nibbles is uneven it is padded with 4-bit 0000 at the end. Warning The length value must be encoded beforhand because its semantics depend on the MainType (see encode_length function). Parameters: Name Type Description Default mtype MainType MainType of component. required stype SubType SubType of component. required version Version Version of component algorithm. 0 length Length length value of component (1 means 64-bits for standard units) 1 Returns: Type Description bytes Varnibble stream encoded ISCC header as bytes. Source code in iscc_core\\codec.py def write_header ( mtype , stype , version = 0 , length = 1 ): # type: (MainType, SubType, Version, Length) -> bytes \"\"\" Encodes header values with nibble-sized (4-bit) variable-length encoding. The result is minimum 2 and maximum 8 bytes long. If the final count of nibbles is uneven it is padded with 4-bit `0000` at the end. !!! warning The length value must be encoded beforhand because its semantics depend on the MainType (see `encode_length` function). :param MainType mtype: MainType of component. :param SubType stype: SubType of component. :param Version version: Version of component algorithm. :param Length length: length value of component (1 means 64-bits for standard units) :return: Varnibble stream encoded ISCC header as bytes. :rtype: bytes \"\"\" # TODO verify that all header params and there combination is valid header = bitarray () for n in ( mtype , stype , version , length ): header += write_varnibble ( n ) # Append zero-padding if required (right side, least significant bits). header . fill () return header . tobytes ()","title":"write_header()"},{"location":"codec/codec/#iscc_core.codec.write_varnibble","text":"Writes integer to variable length sequence of 4-bit chunks. Variable-length encoding scheme: prefix bits nibbles data bits unsigned range 0 1 3 0 - 7 10 2 6 8 - 71 110 3 9 72 - 583 1110 4 12 584 - 4679 Parameters: Name Type Description Default n int Positive integer to be encoded as varnibble (0-4679) required Returns: Type Description bitarray Varnibble encoded integera Source code in iscc_core\\codec.py def write_varnibble ( n ): # type: (int) -> bitarray \"\"\" Writes integer to variable length sequence of 4-bit chunks. Variable-length encoding scheme: ------------------------------------------------------ | prefix bits | nibbles | data bits | unsigned range | | ----------- | ------- | --------- | -------------- | | 0 | 1 | 3 | 0 - 7 | | 10 | 2 | 6 | 8 - 71 | | 110 | 3 | 9 | 72 - 583 | | 1110 | 4 | 12 | 584 - 4679 | :param int n: Positive integer to be encoded as varnibble (0-4679) :return: Varnibble encoded integera :rtype: bitarray \"\"\" if 0 <= n < 8 : return int2ba ( n , length = 4 ) elif 8 <= n < 72 : return bitarray ( \"10\" ) + int2ba ( n - 8 , length = 6 ) elif 72 <= n < 584 : return bitarray ( \"110\" ) + int2ba ( n - 72 , length = 9 ) elif 584 <= n < 4680 : return bitarray ( \"1110\" ) + int2ba ( n - 584 , length = 12 ) else : raise ValueError ( \"Value must be between 0 and 4679\" )","title":"write_varnibble()"},{"location":"codec/codec/#iscc_core.codec.read_header","text":"Decodes varnibble encoded header and returns it together with tail data . Tail data is included to enable decoding of sequential ISCCs. The returned tail data must be truncated to decode_length(r[0], r[3]) bits to recover the actual hash-bytes. Parameters: Name Type Description Default data bytes ISCC bytes required Returns: Type Description IsccTuple (MainType, SubType, Version, length, TailData) Source code in iscc_core\\codec.py def read_header ( data ): # type: (bytes) -> IsccTuple \"\"\" Decodes varnibble encoded header and returns it together with `tail data`. Tail data is included to enable decoding of sequential ISCCs. The returned tail data must be truncated to decode_length(r[0], r[3]) bits to recover the actual hash-bytes. :param bytes data: ISCC bytes :return: (MainType, SubType, Version, length, TailData) :rtype: IsccTuple \"\"\" result = [] ba = bitarray () ba . frombytes ( data ) data = ba for _ in range ( 4 ): value , data = read_varnibble ( data ) result . append ( value ) # TODO: validate correctness of decoded data. # Strip 4-bit padding if required if len ( data ) % 8 and data [: 4 ] == bitarray ( \"0000\" ): data = data [ 4 :] result . append ( data . tobytes ()) return tuple ( result )","title":"read_header()"},{"location":"codec/codec/#iscc_core.codec.read_varnibble","text":"Reads first varnibble, returns its integer value and remaining bits. Parameters: Name Type Description Default b bitarray Array of header bits required Returns: Type Description Tuple[int, bitarray] A tuple of the integer value of first varnible and the remaining bits. Source code in iscc_core\\codec.py def read_varnibble ( b ): # type: (bitarray) -> Tuple[int, bitarray] \"\"\"Reads first varnibble, returns its integer value and remaining bits. :param bitarray b: Array of header bits :return: A tuple of the integer value of first varnible and the remaining bits. :rtype: Tuple[int, bitarray] \"\"\" bits = len ( b ) if bits >= 4 and b [ 0 ] == 0 : return ba2int ( b [: 4 ]), b [ 4 :] if bits >= 8 and b [ 1 ] == 0 : return ba2int ( b [ 2 : 8 ]) + 8 , b [ 8 :] if bits >= 12 and b [ 2 ] == 0 : return ba2int ( b [ 3 : 12 ]) + 72 , b [ 12 :] if bits >= 16 and b [ 3 ] == 0 : return ba2int ( b [ 4 : 16 ]) + 584 , b [ 16 :] raise ValueError ( \"Invalid bitarray\" )","title":"read_varnibble()"},{"location":"codec/codec/#iscc_core.codec.encode_units","text":"Encodes a combination of ISCC units to an integer between 0-7 to be used as length value for the final encoding of MT.ISCC Parameters: Name Type Description Default units Tuple A tuple of a MainType combination (can be empty) required Returns: Type Description int Integer value to be used as length-value for header encoding Source code in iscc_core\\codec.py def encode_units ( units ): # type: (Tuple[MT, ...]) -> int \"\"\" Encodes a combination of ISCC units to an integer between 0-7 to be used as length value for the final encoding of MT.ISCC :param Tuple units: A tuple of a MainType combination (can be empty) :return: Integer value to be used as length-value for header encoding :rtype: int \"\"\" return UNITS . index ( units )","title":"encode_units()"},{"location":"codec/codec/#iscc_core.codec.decode_units","text":"Decodes an ISCC header length value that has been encoded with a unit_id to an ordered tuple of MainTypes. Source code in iscc_core\\codec.py def decode_units ( unit_id ): # type: (int) -> Tuple[MT, ...] \"\"\" Decodes an ISCC header length value that has been encoded with a unit_id to an ordered tuple of MainTypes. \"\"\" units = sorted ( UNITS [ unit_id ]) return tuple ( MT ( u ) for u in units )","title":"decode_units()"},{"location":"codec/codec/#iscc_core.codec.encode_length","text":"Encode length to integer value for header encoding. The length value has MainType-specific semantics: For MainTypes META , SEMANTIC , CONTENT , DATA , INSTANCE : Length means number of bits for the body. Length is encoded as the multiple of 32-bit chunks (0 being 32bits) Examples: 32 -> 0, 64 -> 1, 96 -> 2 ... For MainType ISCC : MainTypes `DATA` and `INSTANCE` are mandatory for ISCC-CODEs, all others are optional. Length means the composition of optional 64-bit components included in the ISCC composite. Examples: No optional components -> 0000 -> 0 CONTENT -> 0001 -> 1 SEMANTIC -> 0010 -> 2 SEMANTIC, CONTENT -> 0011 -> 3 META -> 0100 -> 4 META, CONTENT -> 0101 -> 5 ... For MainType ID : Lengths means number the number of bits for the body including the counter Length is encoded as number of bytes of the counter (64-bit body is implicit) Examples: 64 -> 0 (No counter) 72 -> 1 (One byte counter) 80 -> 2 (Two byte counter) ... Parameters: Name Type Description Default mtype MainType The MainType for which to encode the length value. required length Length The length expressed according to the semantics of the type required Returns: Type Description int The length value encoded as integer for use with write_header. Source code in iscc_core\\codec.py def encode_length ( mtype , length ): # type: (MainType, Length) -> int \"\"\" Encode length to integer value for header encoding. The `length` value has MainType-specific semantics: For MainTypes `META`, `SEMANTIC`, `CONTENT`, `DATA`, `INSTANCE`: Length means number of bits for the body. Length is encoded as the multiple of 32-bit chunks (0 being 32bits) Examples: 32 -> 0, 64 -> 1, 96 -> 2 ... For MainType `ISCC`: MainTypes `DATA` and `INSTANCE` are mandatory for ISCC-CODEs, all others are optional. Length means the composition of optional 64-bit components included in the ISCC composite. Examples: No optional components -> 0000 -> 0 CONTENT -> 0001 -> 1 SEMANTIC -> 0010 -> 2 SEMANTIC, CONTENT -> 0011 -> 3 META -> 0100 -> 4 META, CONTENT -> 0101 -> 5 ... For MainType `ID`: Lengths means number the number of bits for the body including the counter Length is encoded as number of bytes of the counter (64-bit body is implicit) Examples: 64 -> 0 (No counter) 72 -> 1 (One byte counter) 80 -> 2 (Two byte counter) ... :param MainType mtype: The MainType for which to encode the length value. :param Length length: The length expressed according to the semantics of the type :return: The length value encoded as integer for use with write_header. :rtype: int \"\"\" error = f \"Invalid length { length } for MainType { mtype } \" # standard case (length field denotes number of 32-bit chunks, 0 being 32-bits) if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE ): if length >= 32 and not length % 32 : return ( length // 32 ) - 1 raise ValueError ( error ) # flag type encoding of included components (pass through as encoded out-of-band) elif mtype == MT . ISCC : if 0 <= length <= 7 : return length raise ValueError ( error ) # counter byte lenght encoding elif mtype == MT . ID : if 64 <= length <= 96 : return ( length - 64 ) // 8 raise ValueError ( error ) else : raise ValueError ( error )","title":"encode_length()"},{"location":"codec/codec/#iscc_core.codec.decode_length","text":"Dedoce raw length value from ISCC header to length of digest in number of bits. Decodes a raw header integer value in to its semantically meaningfull value (eg. number of bits) Source code in iscc_core\\codec.py def decode_length ( mtype , length ): # type: (MainType, Length) -> LN \"\"\" Dedoce raw length value from ISCC header to length of digest in number of bits. Decodes a raw header integer value in to its semantically meaningfull value (eg. number of bits) \"\"\" if mtype in ( MT . META , MT . SEMANTIC , MT . CONTENT , MT . DATA , MT . INSTANCE ): return LN (( length + 1 ) * 32 ) elif mtype == MT . ISCC : return LN ( len ( decode_units ( length )) * 64 + 128 ) elif mtype == MT . ID : return LN ( length * 8 + 64 ) else : raise ValueError ( f \"Invalid length { length } for MainType { mtype } \" )","title":"decode_length()"},{"location":"codec/codec/#iscc_core.codec.encode_base32","text":"Standard RFC4648 base32 encoding without padding. Source code in iscc_core\\codec.py def encode_base32 ( data ): # type: (bytes) -> str \"\"\" Standard RFC4648 base32 encoding without padding. \"\"\" return b32encode ( data ) . decode ( \"ascii\" ) . rstrip ( \"=\" )","title":"encode_base32()"},{"location":"codec/codec/#iscc_core.codec.decode_base32","text":"Standard RFC4648 base32 decoding without padding and with casefolding. Source code in iscc_core\\codec.py def decode_base32 ( code ): # type: (str) -> bytes \"\"\" Standard RFC4648 base32 decoding without padding and with casefolding. \"\"\" # python stdlib does not support base32 without padding, so we have to re-pad. cl = len ( code ) pad_length = math . ceil ( cl / 8 ) * 8 - cl return bytes ( b32decode ( code + \"=\" * pad_length , casefold = True ))","title":"decode_base32()"},{"location":"codec/codec/#iscc_core.codec.encode_base64","text":"Standard RFC4648 base64url encoding without padding. Source code in iscc_core\\codec.py def encode_base64 ( data : bytes ) -> str : \"\"\" Standard RFC4648 base64url encoding without padding. \"\"\" code = urlsafe_b64encode ( data ) . decode ( \"ascii\" ) return code . rstrip ( \"=\" )","title":"encode_base64()"},{"location":"codec/codec/#iscc_core.codec.decode_base64","text":"Standard RFC4648 base64url decoding without padding. Source code in iscc_core\\codec.py def decode_base64 ( code : str ) -> bytes : \"\"\" Standard RFC4648 base64url decoding without padding. \"\"\" padding = 4 - ( len ( code ) % 4 ) string = code + ( \"=\" * padding ) return urlsafe_b64decode ( string )","title":"decode_base64()"},{"location":"codec/codec/#iscc_core.codec.decompose","text":"Decompose an ISCC-CODE or any valid ISCC sequence into a list of ISCC-UNITS. A valid ISCC sequence is a string concatenation of ISCC-UNITS optionally seperated by a hyphen. Source code in iscc_core\\codec.py def decompose ( iscc_code ): # type: (str) -> List[str] \"\"\" Decompose an ISCC-CODE or any valid ISCC sequence into a list of ISCC-UNITS. A valid ISCC sequence is a string concatenation of ISCC-UNITS optionally seperated by a hyphen. \"\"\" iscc_code = clean ( iscc_code ) components = [] raw_code = decode_base32 ( iscc_code ) while raw_code : mt , st , vs , ln , body = read_header ( raw_code ) # standard ISCC-UNIT with tail continuation if mt != MT . ISCC : ln_bits = decode_length ( mt , ln ) code = encode_component ( mt , st , vs , ln_bits , body [: ln_bits // 8 ]) components . append ( code ) raw_code = body [ ln_bits // 8 :] continue # ISCC-CODE main_types = decode_units ( ln ) # rebuild dynamic units (META, SEMANTIC, CONTENT) for idx , mtype in enumerate ( main_types ): stype = ST . NONE if mtype == MT . META else st code = encode_component ( mtype , stype , vs , 64 , body [ idx * 8 :]) components . append ( code ) # rebuild static units (DATA, INSTANCE) data_code = encode_component ( MT . DATA , ST . NONE , vs , 64 , body [ - 16 : - 8 ]) instance_code = encode_component ( MT . INSTANCE , ST . NONE , vs , 64 , body [ - 8 :]) components . extend ([ data_code , instance_code ]) break return components","title":"decompose()"},{"location":"codec/codec/#iscc_core.codec.normalize","text":"Normalize an ISCC to its canonical URI form. The canonical form of an ISCC is its shortest base32 encoded representation prefixed with the string ISCC: . Possible valid inputs: MEACB7X7777574L6 ISCC:MEACB7X7777574L6 fcc010001657fe7cafe9791bb iscc:maagztfqttvizpjr Iscc:Maagztfqttvizpjr Info A concatenated sequence of codes will be composed into a single ISCC of MainType MT.ISCC if possible. Example >>> import iscc_core >>> iscc_core . normalize ( \"GAAW2PRCRS5LNVZV-IAAUVACQKXE3V44W\" ) ISCC : KUBW2PRCRS5LNVZVJKAFAVOJXLZZM Parameters: Name Type Description Default iscc_code str Any valid ISCC string required Returns: Type Description str Normalized ISCC Source code in iscc_core\\codec.py def normalize ( iscc_code ): # type: (str) -> str \"\"\" Normalize an ISCC to its canonical URI form. The canonical form of an ISCC is its shortest base32 encoded representation prefixed with the string `ISCC:`. Possible valid inputs: MEACB7X7777574L6 ISCC:MEACB7X7777574L6 fcc010001657fe7cafe9791bb iscc:maagztfqttvizpjr Iscc:Maagztfqttvizpjr !!! info A concatenated sequence of codes will be composed into a single ISCC of MainType `MT.ISCC` if possible. !!! example ``` py >>> import iscc_core >>> iscc_core.normalize(\"GAAW2PRCRS5LNVZV-IAAUVACQKXE3V44W\") ISCC:KUBW2PRCRS5LNVZVJKAFAVOJXLZZM ``` :param str iscc_code: Any valid ISCC string :return: Normalized ISCC :rtype: str \"\"\" from iscc_core.iscc_code import gen_iscc_code_v0 decoders = { MULTIBASE . base16 : bytes . fromhex , # f MULTIBASE . base32 : decode_base32 , # b MULTIBASE . base58btc : base58 . b58decode , # z MULTIBASE . base64url : decode_base64 , # u } # Transcode to base32 if <multibase><multicodec> encoded multibase_prefix = iscc_code [ 0 ] if multibase_prefix in decoders . keys (): decoder = decoders [ multibase_prefix ] decoded = decoder ( iscc_code [ 1 :]) if not decoded . startswith ( Code . mc_prefix ): raise ValueError ( f \"Malformed multiformat codec: { decoded [: 2 ] } \" ) iscc_code = encode_base32 ( decoded [ 2 :]) decomposed = decompose ( iscc_code ) recomposed = gen_iscc_code_v0 ( decomposed ) . iscc if len ( decomposed ) >= 2 else decomposed [ 0 ] return f \"ISCC: { recomposed } \" if not recomposed . startswith ( \"ISCC:\" ) else recomposed","title":"normalize()"},{"location":"codec/codec/#iscc_core.codec.validate","text":"Validate that a given string is a strictly well-formed ISCC. A strictly well-formed ISCC is: an ISCC-CODE or ISCC-UNIT encoded with base32 upper without padding has a valid combination of header values is represented in its canonical URI form Parameters: Name Type Description Default iscc str ISCC string required strict bool Raise an exeption if validation fails (default True) True Returns: Type Description bool True if sting is valid else false. (raises ValueError in strict mode) Source code in iscc_core\\codec.py def validate ( iscc , strict = True ): # type: (str) -> bool \"\"\" Validate that a given string is a *strictly well-formed* ISCC. A *strictly well-formed* ISCC is: - an ISCC-CODE or ISCC-UNIT - encoded with base32 upper without padding - has a valid combination of header values - is represented in its canonical URI form :param str iscc: ISCC string :param bool strict: Raise an exeption if validation fails (default True) :return: True if sting is valid else false. (raises ValueError in strict mode) :rtype: bool \"\"\" # Basic regex validation match = re . match ( \"^ISCC:[A-Z2-7]{10,60}$\" , iscc ) if not match : if strict : raise ValueError ( \"ISCC string does not match ^ISCC:[A-Z2-7]{10,60}$\" ) else : return False # Header valid valid_prefixes = { \"CQ\" , \"EQ\" , \"MA\" , \"EE\" , \"KA\" , \"CI\" , \"KU\" , \"CE\" , \"ME\" , \"IA\" , \"MI\" , \"KM\" , \"EI\" , \"KE\" , \"EM\" , \"CM\" , \"KI\" , \"EA\" , \"GA\" , \"AA\" , \"CA\" , \"KQ\" , } cleaned = clean ( iscc ) prefix = cleaned [: 2 ] if prefix not in valid_prefixes : if strict : raise ValueError ( f \"Header starts with invalid sequence { prefix } \" ) else : return False return True","title":"validate()"},{"location":"codec/codec/#iscc_core.codec.clean","text":"Cleanup ISCC string. Removes leading scheme, dashes, leading/trailing whitespace. Parameters: Name Type Description Default iscc str Any valid ISCC string required Returns: Type Description str Cleaned ISCC string. Source code in iscc_core\\codec.py def clean ( iscc ): # type: (str) -> str \"\"\" Cleanup ISCC string. Removes leading scheme, dashes, leading/trailing whitespace. :param str iscc: Any valid ISCC string :return: Cleaned ISCC string. :rtype: str \"\"\" split = [ part . strip () for part in iscc . strip () . split ( \":\" )] if len ( split ) == 1 : code = split [ 0 ] # remove dashes if not multiformat if code [ 0 ] not in list ( MULTIBASE ): code = code . replace ( \"-\" , \"\" ) return code elif len ( split ) == 2 : scheme , code = split if scheme . lower () != \"iscc\" : raise ValueError ( f \"Invalid scheme: { scheme } \" ) return code . replace ( \"-\" , \"\" ) else : raise ValueError ( f \"Malformed ISCC string: { iscc } \" )","title":"clean()"},{"location":"components/","text":"ISCC - Components # A standard ISCC-Code is build from multiple components. Each component serve a different purpose.","title":"ISCC - Components"},{"location":"components/#iscc-components","text":"A standard ISCC-Code is build from multiple components. Each component serve a different purpose.","title":"ISCC - Components"},{"location":"components/code_data/","text":"ISCC - Data-Code # A similarity perserving hash for binary data (soft hash). gen_data_code ( stream , bits = 64 ) # Create a similarity preserving ISCC Data-Code with the latest standard algorithm. Parameters: Name Type Description Default stream Stream Input data stream. required bits int Bit-length of ISCC Data-Code (default 64). 64 Returns: Type Description ISCC ISCC Data-Code gen_data_code_v0 ( stream , bits = 64 ) # Create an ISCC Data-Code with algorithm v0. Parameters: Name Type Description Default stream Stream Input data stream. required bits int Bit-length of ISCC Data-Code (default 64). 64 Returns: Type Description ISCC ISCC object with Data-Code soft_hash_data_v0 ( stream ) # Create a similarity preserving Data-Hash digest Parameters: Name Type Description Default stream Stream Input data stream. required Returns: Type Description bytes 256-bit Data-Hash (soft-hash) digest used as body for Data-Code DataHasher # Incremental Data-Hash generator. __init__ ( self , data = None ) special # Create a DataHasher Parameters: Name Type Description Default data Optional[Data] initial payload for hashing. None push ( self , data ) # Push data to the Data-Hash generator. digest ( self ) # Calculate 256-bit minhash digest from feature hashes. code ( self , bits = 64 ) # Encode digest as an ISCC Data-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Data-Code 64 Returns: Type Description str ISCC Data-Code DataHasherV0 # Incremental Data-Hash generator. __init__ ( self , data = None ) special # Create a DataHasher Parameters: Name Type Description Default data Optional[Data] initial payload for hashing. None push ( self , data ) # Push data to the Data-Hash generator. digest ( self ) # Calculate 256-bit minhash digest from feature hashes. code ( self , bits = 64 ) # Encode digest as an ISCC Data-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Data-Code 64 Returns: Type Description str ISCC Data-Code","title":"Data-Code"},{"location":"components/code_data/#iscc-data-code","text":"A similarity perserving hash for binary data (soft hash).","title":"ISCC - Data-Code"},{"location":"components/code_data/#iscc_core.code_data.gen_data_code","text":"Create a similarity preserving ISCC Data-Code with the latest standard algorithm. Parameters: Name Type Description Default stream Stream Input data stream. required bits int Bit-length of ISCC Data-Code (default 64). 64 Returns: Type Description ISCC ISCC Data-Code","title":"gen_data_code()"},{"location":"components/code_data/#iscc_core.code_data.gen_data_code_v0","text":"Create an ISCC Data-Code with algorithm v0. Parameters: Name Type Description Default stream Stream Input data stream. required bits int Bit-length of ISCC Data-Code (default 64). 64 Returns: Type Description ISCC ISCC object with Data-Code","title":"gen_data_code_v0()"},{"location":"components/code_data/#iscc_core.code_data.soft_hash_data_v0","text":"Create a similarity preserving Data-Hash digest Parameters: Name Type Description Default stream Stream Input data stream. required Returns: Type Description bytes 256-bit Data-Hash (soft-hash) digest used as body for Data-Code","title":"soft_hash_data_v0()"},{"location":"components/code_data/#iscc_core.code_data.DataHasher","text":"Incremental Data-Hash generator.","title":"DataHasher"},{"location":"components/code_data/#iscc_core.code_data.DataHasher.__init__","text":"Create a DataHasher Parameters: Name Type Description Default data Optional[Data] initial payload for hashing. None","title":"__init__()"},{"location":"components/code_data/#iscc_core.code_data.DataHasher.push","text":"Push data to the Data-Hash generator.","title":"push()"},{"location":"components/code_data/#iscc_core.code_data.DataHasher.digest","text":"Calculate 256-bit minhash digest from feature hashes.","title":"digest()"},{"location":"components/code_data/#iscc_core.code_data.DataHasher.code","text":"Encode digest as an ISCC Data-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Data-Code 64 Returns: Type Description str ISCC Data-Code","title":"code()"},{"location":"components/code_data/#iscc_core.code_data.DataHasherV0","text":"Incremental Data-Hash generator.","title":"DataHasherV0"},{"location":"components/code_data/#iscc_core.code_data.DataHasherV0.__init__","text":"Create a DataHasher Parameters: Name Type Description Default data Optional[Data] initial payload for hashing. None","title":"__init__()"},{"location":"components/code_data/#iscc_core.code_data.DataHasherV0.push","text":"Push data to the Data-Hash generator.","title":"push()"},{"location":"components/code_data/#iscc_core.code_data.DataHasherV0.digest","text":"Calculate 256-bit minhash digest from feature hashes.","title":"digest()"},{"location":"components/code_data/#iscc_core.code_data.DataHasherV0.code","text":"Encode digest as an ISCC Data-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Data-Code 64 Returns: Type Description str ISCC Data-Code","title":"code()"},{"location":"components/code_instance/","text":"ISCC - Instance-Code # A data checksum. gen_instance_code ( stream , bits = 64 ) # Create an ISCC Instance-Code with the latest standard algorithm. Parameters: Name Type Description Default stream Stream Binary data stream for Instance-Code generation required bits int Bit-length resulting Instance-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Instance-Code and properties: datahash, filesize gen_instance_code_v0 ( stream , bits = 64 ) # Create an ISCC Instance-Code with algorithm v0. Parameters: Name Type Description Default stream Stream Binary data stream for Instance-Code generation required bits int Bit-length of resulting Instance-Code (multiple of 64) 64 Returns: Type Description InstanceCode ISCC object with Instance-Code and properties: datahash, filesize hash_instance_v0 ( stream ) # Create 256-bit hash digest for the Instance-Code body Parameters: Name Type Description Default stream Stream Binary data stream for hash generation. required Returns: Type Description bytes 256-bit Instance-Hash digest used as body of Instance-Code InstanceHasher # Incremental Instance-Hash generator. push ( self , data ) # Push data to the Instance-Hash generator. Parameters: Name Type Description Default data Data Data to be hashed required digest ( self ) # Return Instance-Hash Returns: Type Description bytes Instance-Hash digest multihash ( self ) # Retrun blake3 multihash Returns: Type Description str Blake3 hash as base32 endoded 256-bit multihash code ( self , bits = 64 ) # Encode digest as an ISCC Instance-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Instance-Code 64 Returns: Type Description str ISCC Instance-Code InstanceHasherV0 # Incremental Instance-Hash generator. push ( self , data ) # Push data to the Instance-Hash generator. Parameters: Name Type Description Default data Data Data to be hashed required digest ( self ) # Return Instance-Hash Returns: Type Description bytes Instance-Hash digest multihash ( self ) # Retrun blake3 multihash Returns: Type Description str Blake3 hash as base32 endoded 256-bit multihash code ( self , bits = 64 ) # Encode digest as an ISCC Instance-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Instance-Code 64 Returns: Type Description str ISCC Instance-Code","title":"Instance-Code"},{"location":"components/code_instance/#iscc-instance-code","text":"A data checksum.","title":"ISCC - Instance-Code"},{"location":"components/code_instance/#iscc_core.code_instance.gen_instance_code","text":"Create an ISCC Instance-Code with the latest standard algorithm. Parameters: Name Type Description Default stream Stream Binary data stream for Instance-Code generation required bits int Bit-length resulting Instance-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Instance-Code and properties: datahash, filesize","title":"gen_instance_code()"},{"location":"components/code_instance/#iscc_core.code_instance.gen_instance_code_v0","text":"Create an ISCC Instance-Code with algorithm v0. Parameters: Name Type Description Default stream Stream Binary data stream for Instance-Code generation required bits int Bit-length of resulting Instance-Code (multiple of 64) 64 Returns: Type Description InstanceCode ISCC object with Instance-Code and properties: datahash, filesize","title":"gen_instance_code_v0()"},{"location":"components/code_instance/#iscc_core.code_instance.hash_instance_v0","text":"Create 256-bit hash digest for the Instance-Code body Parameters: Name Type Description Default stream Stream Binary data stream for hash generation. required Returns: Type Description bytes 256-bit Instance-Hash digest used as body of Instance-Code","title":"hash_instance_v0()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasher","text":"Incremental Instance-Hash generator.","title":"InstanceHasher"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasher.push","text":"Push data to the Instance-Hash generator. Parameters: Name Type Description Default data Data Data to be hashed required","title":"push()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasher.digest","text":"Return Instance-Hash Returns: Type Description bytes Instance-Hash digest","title":"digest()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasher.multihash","text":"Retrun blake3 multihash Returns: Type Description str Blake3 hash as base32 endoded 256-bit multihash","title":"multihash()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasher.code","text":"Encode digest as an ISCC Instance-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Instance-Code 64 Returns: Type Description str ISCC Instance-Code","title":"code()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasherV0","text":"Incremental Instance-Hash generator.","title":"InstanceHasherV0"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasherV0.push","text":"Push data to the Instance-Hash generator. Parameters: Name Type Description Default data Data Data to be hashed required","title":"push()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasherV0.digest","text":"Return Instance-Hash Returns: Type Description bytes Instance-Hash digest","title":"digest()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasherV0.multihash","text":"Retrun blake3 multihash Returns: Type Description str Blake3 hash as base32 endoded 256-bit multihash","title":"multihash()"},{"location":"components/code_instance/#iscc_core.code_instance.InstanceHasherV0.code","text":"Encode digest as an ISCC Instance-Code component. Parameters: Name Type Description Default bits int Number of bits for the ISCC Instance-Code 64 Returns: Type Description str ISCC Instance-Code","title":"code()"},{"location":"components/code_meta/","text":"ISCC - Meta-Code # A sililarity preserving hash for digital asset metadata . The Meta-Code is the first component of a canonical ISCC. It is calculated as a similarity preserving hash from the metadata of a digital asset. The purpose of the Meta-Code is the discovery of digital assets with similar metadata or spelling mistakes. The metadata supplied to the algorithm is called seed metadata . Seed metadata is composed of a title and an optional generic extra -field that contains descriptive, industry-sector or use-case specific metadata in textual or binary form (e.g. file headers). We do not prescribe a particular schema. gen_meta_code ( name , description = None , bits = 64 ) # Create an ISCC Meta-Code using the latest standard algorithm. Applications that generate ISCCs should prioritize explicitly passed name information. If not available they should try to extract a name form the digital asset itself. If extraction fails, the application should resort to a normalized filename before falling back to an empty string. And optional additional user presentable description may be supplied via the description -field. Markdown will be preserved for presenting the description publicly. The input can be: A textual description of the identified work for disambiguation purposes Structured (JSON) metadata conforming to an industry specific metadata schema Raw bitstream file headers automatically extracted binary file headers A pre-existing industry-specific identifier string Note It is recommended to use the minimal metadata required to disambiguate the work manifested by the digital asset. Parameters: Name Type Description Default name str Name or title of the work manifested by the digital asset required description Union[str,bytes,None] Optional description for disambiguation None bits int Bit-length of resulting Meta-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Meta-Code and properties name, description, metahash gen_meta_code_v0 ( name , description = None , bits = 64 ) # Create an ISCC Meta-Code with the algorithm version 0. Parameters: Name Type Description Default name str Title of the work manifested by the digital asset required description Union[str,bytes,None] Optional metadata for disambiguation None bits int Bit-length of resulting Meta-Code (multiple of 64) 64 Returns: Type Description MetaCode ISCC Meta-Code soft_hash_meta_v0 ( title , extra = None ) # Calculate simmilarity preserving 256-bit hash digest from asset metadata. Textual input should be stripped of markup, normalized and trimmed before hashing. Json metadata should be normalized with JCS Note The processing algorithm depends on the type of the extra input. If the extra field is supplied and non-empty, we create separate hashes for title and extra and interleave them in 32-bit chunks: If the input is None or an empty str / bytes object the Meta-Hash will be generated from the title -field only. If the extra -input is a non-empty text string (str) the string is lower-cased and the processing unit is an utf-8 endoded character (possibly multibyte). The resulting hash is interleaved with the title -hash. If the extra -input is a non-empty bytes object the processing is done bytewise and the resulting hash is interleaved with the title -hash. Parameters: Name Type Description Default title str Title of the work manifested in the digital asset required extra Union[str,bytes,None] Additional metadata for disambiguation None Returns: Type Description bytes 256-bit simhash digest for Meta-Code trim_text ( text , nbytes ) # Trim text such that its utf-8 encoded size does not exceed nbytes .","title":"Meta-Code"},{"location":"components/code_meta/#iscc-meta-code","text":"A sililarity preserving hash for digital asset metadata . The Meta-Code is the first component of a canonical ISCC. It is calculated as a similarity preserving hash from the metadata of a digital asset. The purpose of the Meta-Code is the discovery of digital assets with similar metadata or spelling mistakes. The metadata supplied to the algorithm is called seed metadata . Seed metadata is composed of a title and an optional generic extra -field that contains descriptive, industry-sector or use-case specific metadata in textual or binary form (e.g. file headers). We do not prescribe a particular schema.","title":"ISCC - Meta-Code"},{"location":"components/code_meta/#iscc_core.code_meta.gen_meta_code","text":"Create an ISCC Meta-Code using the latest standard algorithm. Applications that generate ISCCs should prioritize explicitly passed name information. If not available they should try to extract a name form the digital asset itself. If extraction fails, the application should resort to a normalized filename before falling back to an empty string. And optional additional user presentable description may be supplied via the description -field. Markdown will be preserved for presenting the description publicly. The input can be: A textual description of the identified work for disambiguation purposes Structured (JSON) metadata conforming to an industry specific metadata schema Raw bitstream file headers automatically extracted binary file headers A pre-existing industry-specific identifier string Note It is recommended to use the minimal metadata required to disambiguate the work manifested by the digital asset. Parameters: Name Type Description Default name str Name or title of the work manifested by the digital asset required description Union[str,bytes,None] Optional description for disambiguation None bits int Bit-length of resulting Meta-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Meta-Code and properties name, description, metahash","title":"gen_meta_code()"},{"location":"components/code_meta/#iscc_core.code_meta.gen_meta_code_v0","text":"Create an ISCC Meta-Code with the algorithm version 0. Parameters: Name Type Description Default name str Title of the work manifested by the digital asset required description Union[str,bytes,None] Optional metadata for disambiguation None bits int Bit-length of resulting Meta-Code (multiple of 64) 64 Returns: Type Description MetaCode ISCC Meta-Code","title":"gen_meta_code_v0()"},{"location":"components/code_meta/#iscc_core.code_meta.soft_hash_meta_v0","text":"Calculate simmilarity preserving 256-bit hash digest from asset metadata. Textual input should be stripped of markup, normalized and trimmed before hashing. Json metadata should be normalized with JCS Note The processing algorithm depends on the type of the extra input. If the extra field is supplied and non-empty, we create separate hashes for title and extra and interleave them in 32-bit chunks: If the input is None or an empty str / bytes object the Meta-Hash will be generated from the title -field only. If the extra -input is a non-empty text string (str) the string is lower-cased and the processing unit is an utf-8 endoded character (possibly multibyte). The resulting hash is interleaved with the title -hash. If the extra -input is a non-empty bytes object the processing is done bytewise and the resulting hash is interleaved with the title -hash. Parameters: Name Type Description Default title str Title of the work manifested in the digital asset required extra Union[str,bytes,None] Additional metadata for disambiguation None Returns: Type Description bytes 256-bit simhash digest for Meta-Code","title":"soft_hash_meta_v0()"},{"location":"components/code_meta/#iscc_core.code_meta.trim_text","text":"Trim text such that its utf-8 encoded size does not exceed nbytes .","title":"trim_text()"},{"location":"components/content/","text":"ISCC - Content-Codes #","title":"ISCC - Content-Codes"},{"location":"components/content/#iscc-content-codes","text":"","title":"ISCC - Content-Codes"},{"location":"components/content/code_content_audio/","text":"ISCC - Audio-Code # A similarity preserving hash for audio content (soft hash). Creates an ISCC object that provides an iscc -field with an Audio-Code and a duration -field. The Content-Code Audio is generated from a Chromaprint fingerprint provided as a vector of 32-bit signed integers. Chromaprints are extracted with fpcalc 1.5.0 using the following command line parameters: $ fpcalc -raw -json -signed -length 0 myaudiofile.mp3 gen_audio_code ( cv , bits = 64 ) # Create an ISCC Content-Code Audio with the latest standard algorithm. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required bits int Bit-length resulting Content-Code Audio (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Content-Code Audio gen_audio_code_v0 ( cv , bits = 64 ) # Create an ISCC Content-Code Audio with algorithm v0. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required bits int Bit-length resulting Content-Code Audio (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Content-Code Audio soft_hash_audio_v0 ( cv ) # Create 256-bit audio similarity hash from a chromaprint vector. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required Returns: Type Description bytes 256-bit Audio-Hash digest","title":"Audio-Code"},{"location":"components/content/code_content_audio/#iscc-audio-code","text":"A similarity preserving hash for audio content (soft hash). Creates an ISCC object that provides an iscc -field with an Audio-Code and a duration -field. The Content-Code Audio is generated from a Chromaprint fingerprint provided as a vector of 32-bit signed integers. Chromaprints are extracted with fpcalc 1.5.0 using the following command line parameters: $ fpcalc -raw -json -signed -length 0 myaudiofile.mp3","title":"ISCC - Audio-Code"},{"location":"components/content/code_content_audio/#iscc_core.code_content_audio.gen_audio_code","text":"Create an ISCC Content-Code Audio with the latest standard algorithm. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required bits int Bit-length resulting Content-Code Audio (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Content-Code Audio","title":"gen_audio_code()"},{"location":"components/content/code_content_audio/#iscc_core.code_content_audio.gen_audio_code_v0","text":"Create an ISCC Content-Code Audio with algorithm v0. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required bits int Bit-length resulting Content-Code Audio (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Content-Code Audio","title":"gen_audio_code_v0()"},{"location":"components/content/code_content_audio/#iscc_core.code_content_audio.soft_hash_audio_v0","text":"Create 256-bit audio similarity hash from a chromaprint vector. Parameters: Name Type Description Default cv Iterable[int] Chromaprint vector required Returns: Type Description bytes 256-bit Audio-Hash digest","title":"soft_hash_audio_v0()"},{"location":"components/content/code_content_image/","text":"ISCC - Image-Code # A similarity preserving perceptual hash for images. The ISCC Content-Code Image is created by calculating a discrete cosine transform on normalized image-pixels and comparing the values from the upper left area of the dct-matrix against their median values to set the hash-bits. Images must be normalized before using gen_image_code. Prepare images as follows: Transpose image according to EXIF Orientation Add gray background to image if it has alpha transparency (gray value 126) Crop empty borders of image Convert image to grayscale Resize image to 32x32 Flatten 32x32 matrix to an array of 1024 grayscale (uint8) pixel values gen_image_code ( pixels , bits = 64 ) # Create an ISCC Content-Code Image with the latest standard algorithm. Parameters: Name Type Description Default pixels Sequence[int] Normalized image pixels (32x32 flattened gray values). required bits int Bit-length of ISCC Content-Code Image (default 64). 64 Returns: Type Description ISCC ISCC object with Content-Code Image. gen_image_code_v0 ( pixels , bits = 64 ) # Create an ISCC Content-Code Image with algorithm v0. Parameters: Name Type Description Default pixels Sequence[int] Normalized image pixels (32x32 flattened gray values) required bits int Bit-length of ISCC Content-Code Image (default 64). 64 Returns: Type Description ISCC ISCC object with Content-Code Image. soft_hash_image_v0 ( pixels , bits = 64 ) # Calculate image hash from normalized grayscale pixel sequence of length 1024. Parameters: Name Type Description Default pixels Sequence[int] required bits int Bit-length of image hash (default 64). 64 Returns: Type Description bytes Similarity preserving Image-Hash digest.","title":"Image-Code"},{"location":"components/content/code_content_image/#iscc-image-code","text":"A similarity preserving perceptual hash for images. The ISCC Content-Code Image is created by calculating a discrete cosine transform on normalized image-pixels and comparing the values from the upper left area of the dct-matrix against their median values to set the hash-bits. Images must be normalized before using gen_image_code. Prepare images as follows: Transpose image according to EXIF Orientation Add gray background to image if it has alpha transparency (gray value 126) Crop empty borders of image Convert image to grayscale Resize image to 32x32 Flatten 32x32 matrix to an array of 1024 grayscale (uint8) pixel values","title":"ISCC - Image-Code"},{"location":"components/content/code_content_image/#iscc_core.code_content_image.gen_image_code","text":"Create an ISCC Content-Code Image with the latest standard algorithm. Parameters: Name Type Description Default pixels Sequence[int] Normalized image pixels (32x32 flattened gray values). required bits int Bit-length of ISCC Content-Code Image (default 64). 64 Returns: Type Description ISCC ISCC object with Content-Code Image.","title":"gen_image_code()"},{"location":"components/content/code_content_image/#iscc_core.code_content_image.gen_image_code_v0","text":"Create an ISCC Content-Code Image with algorithm v0. Parameters: Name Type Description Default pixels Sequence[int] Normalized image pixels (32x32 flattened gray values) required bits int Bit-length of ISCC Content-Code Image (default 64). 64 Returns: Type Description ISCC ISCC object with Content-Code Image.","title":"gen_image_code_v0()"},{"location":"components/content/code_content_image/#iscc_core.code_content_image.soft_hash_image_v0","text":"Calculate image hash from normalized grayscale pixel sequence of length 1024. Parameters: Name Type Description Default pixels Sequence[int] required bits int Bit-length of image hash (default 64). 64 Returns: Type Description bytes Similarity preserving Image-Hash digest.","title":"soft_hash_image_v0()"},{"location":"components/content/code_content_mixed/","text":"ISCC - Mixed Code # A similarity hash for mixed media content. Creates an ISCC object that provides a iscc -field a Mixed-Code and a parts -field that lists the input codes. Many digital assets embed multiple assets of different mediatypes in a single file. Text documents may include images, video includes audio in most cases. The ISCC Content-Code-Mixed encodes the similarity of a collection of assets of the same or different mediatypes that may occur in a multimedia asset. Applications that create mixed Content-Codes must be capable to extract embedded assets and create individual Content-Codes per asset. gen_mixed_code ( codes , bits = 64 ) # Create an ISCC Content-Code Mixed with the latest standard algorithm. Parameters: Name Type Description Default codes Iterable[str] a list of Content-Codes. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description ISCC ISCC object with Content-Code Mixed. gen_mixed_code_v0 ( codes , bits = 64 ) # Create an ISCC Content-Code-Mixed with algorithm v0. If the provided codes are of mixed length they are stripped to bits length for calculation. Parameters: Name Type Description Default codes Iterable[str] a list of Content-Codes. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description ISCC ISCC object with Content-Code Mixed. soft_hash_codes_v0 ( cc_digests , bits = 64 ) # Create a similarity hash from multiple Content-Code digests. The similarity hash is created from the bodies of the input codes with the first byte of the code-header prepended. All codes must be of main-type CONTENT and have a minimum length of bits . Parameters: Name Type Description Default cc_digests Sequence[bytes] a list of Content-Code digests. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description bytes Similarity preserving byte hash.","title":"Mixed-Code"},{"location":"components/content/code_content_mixed/#iscc-mixed-code","text":"A similarity hash for mixed media content. Creates an ISCC object that provides a iscc -field a Mixed-Code and a parts -field that lists the input codes. Many digital assets embed multiple assets of different mediatypes in a single file. Text documents may include images, video includes audio in most cases. The ISCC Content-Code-Mixed encodes the similarity of a collection of assets of the same or different mediatypes that may occur in a multimedia asset. Applications that create mixed Content-Codes must be capable to extract embedded assets and create individual Content-Codes per asset.","title":"ISCC - Mixed Code"},{"location":"components/content/code_content_mixed/#iscc_core.code_content_mixed.gen_mixed_code","text":"Create an ISCC Content-Code Mixed with the latest standard algorithm. Parameters: Name Type Description Default codes Iterable[str] a list of Content-Codes. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description ISCC ISCC object with Content-Code Mixed.","title":"gen_mixed_code()"},{"location":"components/content/code_content_mixed/#iscc_core.code_content_mixed.gen_mixed_code_v0","text":"Create an ISCC Content-Code-Mixed with algorithm v0. If the provided codes are of mixed length they are stripped to bits length for calculation. Parameters: Name Type Description Default codes Iterable[str] a list of Content-Codes. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description ISCC ISCC object with Content-Code Mixed.","title":"gen_mixed_code_v0()"},{"location":"components/content/code_content_mixed/#iscc_core.code_content_mixed.soft_hash_codes_v0","text":"Create a similarity hash from multiple Content-Code digests. The similarity hash is created from the bodies of the input codes with the first byte of the code-header prepended. All codes must be of main-type CONTENT and have a minimum length of bits . Parameters: Name Type Description Default cc_digests Sequence[bytes] a list of Content-Code digests. required bits int Target bit-length of generated Content-Code-Mixed. 64 Returns: Type Description bytes Similarity preserving byte hash.","title":"soft_hash_codes_v0()"},{"location":"components/content/code_content_text/","text":"ISCC - Text Code # A similarity preserving hash for plain-text content (soft hash). The ISCC Text-Code is generated from plain-text that has been extracted from a media assets. Tip Plain-text extraction from documents in various formats (especially PDF) may yield very diffent results depending on the extraction tools being used. For reproducible Text-Code generation use Apache Tika v2.2.1 to extract text from your documents. Algorithm overview : Normalize text using normalize_text function Count characters of normalized text Remove all whitespace Lowercase text Apply function soft_hash_text_v0 to text gen_text_code_v0 ( text , bits = 64 ) # Create an ISCC Text-Code with algorithm v0. Note Any markup (like HTML tags or markdown) should be removed from the plain-text before passing it to this function. Parameters: Name Type Description Default text Text Text for Text-Code creation required bits int Bit-length of ISCC Code Hash (default 64) 64 Returns: Type Description ISCC ISCC schema instance with Text-Code and an aditional property characters Source code in iscc_core\\code_content_text.py def gen_text_code_v0 ( text , bits = core_opts . text_bits ): # type: (Text, int) -> ISCC \"\"\" Create an ISCC Text-Code with algorithm v0. !!! note Any markup (like HTML tags or markdown) should be removed from the plain-text before passing it to this function. :param Text text: Text for Text-Code creation :param int bits: Bit-length of ISCC Code Hash (default 64) :return: ISCC schema instance with Text-Code and an aditional property `characters` :rtype: ISCC \"\"\" text = normalize_text ( text ) characters = len ( text ) text = \"\" . join ( text . split ()) text = text . lower () digest = soft_hash_text_v0 ( text ) text_code = codec . encode_component ( mtype = codec . MT . CONTENT , stype = codec . ST_CC . TEXT , version = codec . VS . V0 , bit_length = bits , digest = digest , ) iscc = \"ISCC:\" + text_code return ISCC ( iscc = iscc , characters = characters ) normalize_text ( text ) # Unicode normalization and character filtering. Decode to Unicode. Remove leading/trailing whitespace. Decompose with NFD normalization. Filter special characters and whitespace. Remove duplicate whitespace. Recombine with NFKC normalization. Parameters: Name Type Description Default text Text Plain text to be normalized. required Returns: Type Description str Normalized plain text. Source code in iscc_core\\code_content_text.py def normalize_text ( text ): # type: (Text) -> str \"\"\" [Unicode normalization](https://unicode.org/reports/tr15/) and character filtering. - Decode to Unicode. - Remove leading/trailing whitespace. - Decompose with NFD normalization. - Filter special characters and whitespace. - Remove duplicate whitespace. - Recombine with NFKC normalization. :param Text text: Plain text to be normalized. :return: Normalized plain text. :rtype: str \"\"\" # 1. Convert bytes to str if isinstance ( text , bytes ): text = text . decode ( \"utf-8\" ) # 2. Remove leading/trailing whitespace text_stripped = text . strip () # 3. Decompose with NFD text_decomposed = unicodedata . normalize ( \"NFD\" , text_stripped ) # 4. Filter chars = [] for c in text_decomposed : cat = unicodedata . category ( c ) if cat not in core_opts . text_unicode_filter : chars . append ( c ) elif c in core_opts . text_whitespace : chars . append ( c ) text_filtered = \"\" . join ( chars ) # 5. Collapse consecutive whitespace wsproc_text = \" \" . join ( text_filtered . split ()) # 6. Recombine recombined = unicodedata . normalize ( \"NFKC\" , wsproc_text ) return recombined soft_hash_text_v0 ( text ) # Creates a 256-bit similarity preserving hash for text input with algorithm v0. Slide over text with a text_ngram_size wide window and create xxh32 hashes Create a minhash_256 from the hashes generated in the previous step. Note Before passing text to this function it must be: stripped of markup normalized stripped of whitespace lowercased Parameters: Name Type Description Default text str Plain text to be hashed. required Returns: Type Description bytes 256-bit similarity preserving byte hash. Source code in iscc_core\\code_content_text.py def soft_hash_text_v0 ( text ): # type: (str) -> bytes \"\"\" Creates a 256-bit similarity preserving hash for text input with algorithm v0. - Slide over text with a [`text_ngram_size`][iscc_core.options.CoreOptions.text_ngram_size] wide window and create [`xxh32`](https://cyan4973.github.io/xxHash/) hashes - Create a [`minhash_256`][iscc_core.minhash.minhash_256] from the hashes generated in the previous step. !!! note Before passing text to this function it must be: - stripped of markup - normalized - stripped of whitespace - lowercased :param str text: Plain text to be hashed. :return: 256-bit similarity preserving byte hash. :rtype: bytes \"\"\" ngrams = sliding_window ( text , core_opts . text_ngram_size ) features = [ xxhash . xxh32_intdigest ( s . encode ( \"utf-8\" )) for s in ngrams ] hash_digest = minhash_256 ( features ) return hash_digest","title":"Text-Code"},{"location":"components/content/code_content_text/#iscc-text-code","text":"A similarity preserving hash for plain-text content (soft hash). The ISCC Text-Code is generated from plain-text that has been extracted from a media assets. Tip Plain-text extraction from documents in various formats (especially PDF) may yield very diffent results depending on the extraction tools being used. For reproducible Text-Code generation use Apache Tika v2.2.1 to extract text from your documents. Algorithm overview : Normalize text using normalize_text function Count characters of normalized text Remove all whitespace Lowercase text Apply function soft_hash_text_v0 to text","title":"ISCC - Text Code"},{"location":"components/content/code_content_text/#iscc_core.code_content_text.gen_text_code_v0","text":"Create an ISCC Text-Code with algorithm v0. Note Any markup (like HTML tags or markdown) should be removed from the plain-text before passing it to this function. Parameters: Name Type Description Default text Text Text for Text-Code creation required bits int Bit-length of ISCC Code Hash (default 64) 64 Returns: Type Description ISCC ISCC schema instance with Text-Code and an aditional property characters Source code in iscc_core\\code_content_text.py def gen_text_code_v0 ( text , bits = core_opts . text_bits ): # type: (Text, int) -> ISCC \"\"\" Create an ISCC Text-Code with algorithm v0. !!! note Any markup (like HTML tags or markdown) should be removed from the plain-text before passing it to this function. :param Text text: Text for Text-Code creation :param int bits: Bit-length of ISCC Code Hash (default 64) :return: ISCC schema instance with Text-Code and an aditional property `characters` :rtype: ISCC \"\"\" text = normalize_text ( text ) characters = len ( text ) text = \"\" . join ( text . split ()) text = text . lower () digest = soft_hash_text_v0 ( text ) text_code = codec . encode_component ( mtype = codec . MT . CONTENT , stype = codec . ST_CC . TEXT , version = codec . VS . V0 , bit_length = bits , digest = digest , ) iscc = \"ISCC:\" + text_code return ISCC ( iscc = iscc , characters = characters )","title":"gen_text_code_v0()"},{"location":"components/content/code_content_text/#iscc_core.code_content_text.normalize_text","text":"Unicode normalization and character filtering. Decode to Unicode. Remove leading/trailing whitespace. Decompose with NFD normalization. Filter special characters and whitespace. Remove duplicate whitespace. Recombine with NFKC normalization. Parameters: Name Type Description Default text Text Plain text to be normalized. required Returns: Type Description str Normalized plain text. Source code in iscc_core\\code_content_text.py def normalize_text ( text ): # type: (Text) -> str \"\"\" [Unicode normalization](https://unicode.org/reports/tr15/) and character filtering. - Decode to Unicode. - Remove leading/trailing whitespace. - Decompose with NFD normalization. - Filter special characters and whitespace. - Remove duplicate whitespace. - Recombine with NFKC normalization. :param Text text: Plain text to be normalized. :return: Normalized plain text. :rtype: str \"\"\" # 1. Convert bytes to str if isinstance ( text , bytes ): text = text . decode ( \"utf-8\" ) # 2. Remove leading/trailing whitespace text_stripped = text . strip () # 3. Decompose with NFD text_decomposed = unicodedata . normalize ( \"NFD\" , text_stripped ) # 4. Filter chars = [] for c in text_decomposed : cat = unicodedata . category ( c ) if cat not in core_opts . text_unicode_filter : chars . append ( c ) elif c in core_opts . text_whitespace : chars . append ( c ) text_filtered = \"\" . join ( chars ) # 5. Collapse consecutive whitespace wsproc_text = \" \" . join ( text_filtered . split ()) # 6. Recombine recombined = unicodedata . normalize ( \"NFKC\" , wsproc_text ) return recombined","title":"normalize_text()"},{"location":"components/content/code_content_text/#iscc_core.code_content_text.soft_hash_text_v0","text":"Creates a 256-bit similarity preserving hash for text input with algorithm v0. Slide over text with a text_ngram_size wide window and create xxh32 hashes Create a minhash_256 from the hashes generated in the previous step. Note Before passing text to this function it must be: stripped of markup normalized stripped of whitespace lowercased Parameters: Name Type Description Default text str Plain text to be hashed. required Returns: Type Description bytes 256-bit similarity preserving byte hash. Source code in iscc_core\\code_content_text.py def soft_hash_text_v0 ( text ): # type: (str) -> bytes \"\"\" Creates a 256-bit similarity preserving hash for text input with algorithm v0. - Slide over text with a [`text_ngram_size`][iscc_core.options.CoreOptions.text_ngram_size] wide window and create [`xxh32`](https://cyan4973.github.io/xxHash/) hashes - Create a [`minhash_256`][iscc_core.minhash.minhash_256] from the hashes generated in the previous step. !!! note Before passing text to this function it must be: - stripped of markup - normalized - stripped of whitespace - lowercased :param str text: Plain text to be hashed. :return: 256-bit similarity preserving byte hash. :rtype: bytes \"\"\" ngrams = sliding_window ( text , core_opts . text_ngram_size ) features = [ xxhash . xxh32_intdigest ( s . encode ( \"utf-8\" )) for s in ngrams ] hash_digest = minhash_256 ( features ) return hash_digest","title":"soft_hash_text_v0()"},{"location":"components/content/code_content_video/","text":"ISCC - Video-Code # A similarity preserving hash for video content The Content-Code Video is generated from MPEG-7 Video Frame Signatures. Frame Signatures can be extracted with ffmpeg (see: https://www.ffmpeg.org/) using the following command line parameters: $ ffmpeg -i video.mpg -vf fps=fps=5,signature=format=xml:filename=sig.xml -f null - The relevant frame signatures can be parsed from the following elements in sig.xml: <FrameSignature>0 0 0 1 0 0 1 0 1 1 0 0 1 1 ...</FrameSignature> Note it is also possible to extract the signatures in a more compact binary format but it requires a custom binary parser to decode the frame signaturs. gen_video_code ( frame_sigs , bits = 64 ) # Create an ISCC Video-Code with the latest standard algorithm. Parameters: Name Type Description Default frame_sigs FrameSig Sequence of MP7 frame signatures required bits int Bit-length resulting Instance-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Video-Code gen_video_code_v0 ( frame_sigs , bits = 64 ) # Create an ISCC Video-Code with algorithm v0. Parameters: Name Type Description Default frame_sigs FrameSig Sequence of MP7 frame signatures required bits int Bit-length resulting Video-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Video-Code soft_hash_video_v0 ( frame_sigs , bits = 64 ) # Compute video hash v0 from MP7 frame signatures. Parameters: Name Type Description Default frame_sigs Sequence[Sequence[int]] 2D matrix of MP7 frame signatures required bits int Bit-length resulting Instance-Code (multiple of 64) 64","title":"Video-Code"},{"location":"components/content/code_content_video/#iscc-video-code","text":"A similarity preserving hash for video content The Content-Code Video is generated from MPEG-7 Video Frame Signatures. Frame Signatures can be extracted with ffmpeg (see: https://www.ffmpeg.org/) using the following command line parameters: $ ffmpeg -i video.mpg -vf fps=fps=5,signature=format=xml:filename=sig.xml -f null - The relevant frame signatures can be parsed from the following elements in sig.xml: <FrameSignature>0 0 0 1 0 0 1 0 1 1 0 0 1 1 ...</FrameSignature> Note it is also possible to extract the signatures in a more compact binary format but it requires a custom binary parser to decode the frame signaturs.","title":"ISCC - Video-Code"},{"location":"components/content/code_content_video/#iscc_core.code_content_video.gen_video_code","text":"Create an ISCC Video-Code with the latest standard algorithm. Parameters: Name Type Description Default frame_sigs FrameSig Sequence of MP7 frame signatures required bits int Bit-length resulting Instance-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Video-Code","title":"gen_video_code()"},{"location":"components/content/code_content_video/#iscc_core.code_content_video.gen_video_code_v0","text":"Create an ISCC Video-Code with algorithm v0. Parameters: Name Type Description Default frame_sigs FrameSig Sequence of MP7 frame signatures required bits int Bit-length resulting Video-Code (multiple of 64) 64 Returns: Type Description ISCC ISCC object with Video-Code","title":"gen_video_code_v0()"},{"location":"components/content/code_content_video/#iscc_core.code_content_video.soft_hash_video_v0","text":"Compute video hash v0 from MP7 frame signatures. Parameters: Name Type Description Default frame_sigs Sequence[Sequence[int]] 2D matrix of MP7 frame signatures required bits int Bit-length resulting Instance-Code (multiple of 64) 64","title":"soft_hash_video_v0()"},{"location":"context/0.2.0/","text":"ISCC - Metadata Vocabulary (v0.2.0) # @context # JSON-LD Context URI type # JSON Schema URI iscc # ISCC in canonical encoding. name # The name or title of the intangible creation manifested by the identified digital asset description # Description of the digital asset identified by the ISCC (used as input for Meta-Code generation). Any user presentable text string (including Markdown text) indicative of the identity of the referent may be used. image # URI for a user presentable image that serves as a preview of identified digital content or, in case of an NFT, the digital content itself. keywords # List of keywords relevant to the identified digital content. identifier # Other identifier(s) such as those defined by ISO/TC 46/SC 9 referencing the work, product or other abstraction of which the referenced digital asset is a full or partial manifestation. filename # Filename of the referenced digital asset (automatically used as fallback if no seed_title element is specified) filesize # File size of media asset in bytes. mediatype # IANA Media Type (MIME type) tophash # Multihash hash over concatenation of metahash and datahash metahash # Multihash hash of metadata. datahash # Multihash hash of media file. duration # Duration of audio-visual media in secondes. fps # Frames per second of video assets. width # Width of visual media in pixels. height # Height of visual media in pixels. characters # Number of text characters (code points after Unicode normalization) language # Language(s) of content (BCP-47) in weighted order. parts # Included Content-Codes. license # URI of license for the identified digital content. redirect # URL to which a resolver should redirect an ISCC-ID that has been minted from a declartion that includes the IPFS-hash of this metadata instance.","title":"ISCC - Metadata Vocabulary (v0.2.0)"},{"location":"context/0.2.0/#iscc-metadata-vocabulary-v020","text":"","title":"ISCC - Metadata Vocabulary (v0.2.0)"},{"location":"context/0.2.0/#context","text":"JSON-LD Context URI","title":"@context"},{"location":"context/0.2.0/#type","text":"JSON Schema URI","title":"type"},{"location":"context/0.2.0/#iscc","text":"ISCC in canonical encoding.","title":"iscc"},{"location":"context/0.2.0/#name","text":"The name or title of the intangible creation manifested by the identified digital asset","title":"name"},{"location":"context/0.2.0/#description","text":"Description of the digital asset identified by the ISCC (used as input for Meta-Code generation). Any user presentable text string (including Markdown text) indicative of the identity of the referent may be used.","title":"description"},{"location":"context/0.2.0/#image","text":"URI for a user presentable image that serves as a preview of identified digital content or, in case of an NFT, the digital content itself.","title":"image"},{"location":"context/0.2.0/#keywords","text":"List of keywords relevant to the identified digital content.","title":"keywords"},{"location":"context/0.2.0/#identifier","text":"Other identifier(s) such as those defined by ISO/TC 46/SC 9 referencing the work, product or other abstraction of which the referenced digital asset is a full or partial manifestation.","title":"identifier"},{"location":"context/0.2.0/#filename","text":"Filename of the referenced digital asset (automatically used as fallback if no seed_title element is specified)","title":"filename"},{"location":"context/0.2.0/#filesize","text":"File size of media asset in bytes.","title":"filesize"},{"location":"context/0.2.0/#mediatype","text":"IANA Media Type (MIME type)","title":"mediatype"},{"location":"context/0.2.0/#tophash","text":"Multihash hash over concatenation of metahash and datahash","title":"tophash"},{"location":"context/0.2.0/#metahash","text":"Multihash hash of metadata.","title":"metahash"},{"location":"context/0.2.0/#datahash","text":"Multihash hash of media file.","title":"datahash"},{"location":"context/0.2.0/#duration","text":"Duration of audio-visual media in secondes.","title":"duration"},{"location":"context/0.2.0/#fps","text":"Frames per second of video assets.","title":"fps"},{"location":"context/0.2.0/#width","text":"Width of visual media in pixels.","title":"width"},{"location":"context/0.2.0/#height","text":"Height of visual media in pixels.","title":"height"},{"location":"context/0.2.0/#characters","text":"Number of text characters (code points after Unicode normalization)","title":"characters"},{"location":"context/0.2.0/#language","text":"Language(s) of content (BCP-47) in weighted order.","title":"language"},{"location":"context/0.2.0/#parts","text":"Included Content-Codes.","title":"parts"},{"location":"context/0.2.0/#license","text":"URI of license for the identified digital content.","title":"license"},{"location":"context/0.2.0/#redirect","text":"URL to which a resolver should redirect an ISCC-ID that has been minted from a declartion that includes the IPFS-hash of this metadata instance.","title":"redirect"},{"location":"includes/abbr/","text":"","title":"Abbr"},{"location":"options/options/","text":"CoreOptions pydantic-model # Parameters with defaults for ISCC calculations. meta_bits : int pydantic-field # Default length of generated Meta-Code in bits meta_trim_title : int pydantic-field # Trim title length to this mumber of bytes meta_trim_extra : int pydantic-field # Trim extra to this number of bytes meta_ngram_size_title : int pydantic-field # Sliding window width (characters) for title metadata meta_ngram_size_extra_text : int pydantic-field # Sliding window width (characters) for textural extra metadata meta_ngram_size_extra_binary : int pydantic-field # Sliding window width (bytes) for binary extra metadata text_bits : int pydantic-field # Default length of generated Content-Code Text in bits text_ngram_size : int pydantic-field # Number of characters per feature hash (size of sliding window) text_unicode_filter : frozenset pydantic-field # Unicode categories to remove during text normalization text_whitespace : frozenset pydantic-field # Common control characters considered whitespace image_bits : int pydantic-field # Default length of generated Content-Code Image in bits audio_bits : int pydantic-field # Default length of generated Content-Code Audio in bits video_bits : int pydantic-field # Default length of generated Content-Code Video in bits data_bits : int pydantic-field # Default length of generated Data-Code in bits data_avg_chunk_size : int pydantic-field # Target chunk size for data chunking in number of bytes. instance_bits : int pydantic-field # Default length of generated Instance-Code in bits mixed_bits : int pydantic-field # Default length of generated Mixed-Code in bits io_read_size : int pydantic-field # File read buffer size in bytes for hashing operations cdc_gear : Tuple pydantic-field # Random gear vector check_options ( opts ) # Check and log if options have non-default conformance critical values","title":"Options"},{"location":"options/options/#iscc_core.options.CoreOptions","text":"Parameters with defaults for ISCC calculations.","title":"CoreOptions"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_bits","text":"Default length of generated Meta-Code in bits","title":"meta_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_trim_title","text":"Trim title length to this mumber of bytes","title":"meta_trim_title"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_trim_extra","text":"Trim extra to this number of bytes","title":"meta_trim_extra"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_ngram_size_title","text":"Sliding window width (characters) for title metadata","title":"meta_ngram_size_title"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_ngram_size_extra_text","text":"Sliding window width (characters) for textural extra metadata","title":"meta_ngram_size_extra_text"},{"location":"options/options/#iscc_core.options.CoreOptions.meta_ngram_size_extra_binary","text":"Sliding window width (bytes) for binary extra metadata","title":"meta_ngram_size_extra_binary"},{"location":"options/options/#iscc_core.options.CoreOptions.text_bits","text":"Default length of generated Content-Code Text in bits","title":"text_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.text_ngram_size","text":"Number of characters per feature hash (size of sliding window)","title":"text_ngram_size"},{"location":"options/options/#iscc_core.options.CoreOptions.text_unicode_filter","text":"Unicode categories to remove during text normalization","title":"text_unicode_filter"},{"location":"options/options/#iscc_core.options.CoreOptions.text_whitespace","text":"Common control characters considered whitespace","title":"text_whitespace"},{"location":"options/options/#iscc_core.options.CoreOptions.image_bits","text":"Default length of generated Content-Code Image in bits","title":"image_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.audio_bits","text":"Default length of generated Content-Code Audio in bits","title":"audio_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.video_bits","text":"Default length of generated Content-Code Video in bits","title":"video_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.data_bits","text":"Default length of generated Data-Code in bits","title":"data_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.data_avg_chunk_size","text":"Target chunk size for data chunking in number of bytes.","title":"data_avg_chunk_size"},{"location":"options/options/#iscc_core.options.CoreOptions.instance_bits","text":"Default length of generated Instance-Code in bits","title":"instance_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.mixed_bits","text":"Default length of generated Mixed-Code in bits","title":"mixed_bits"},{"location":"options/options/#iscc_core.options.CoreOptions.io_read_size","text":"File read buffer size in bytes for hashing operations","title":"io_read_size"},{"location":"options/options/#iscc_core.options.CoreOptions.cdc_gear","text":"Random gear vector","title":"cdc_gear"},{"location":"options/options/#iscc_core.options.check_options","text":"Check and log if options have non-default conformance critical values","title":"check_options()"},{"location":"schema/schema/","text":"ISCC - Schema # Schema of objects returned by ISCC processing algorithms. The schemata define standard fields to be set by ISCC generating applications. This library only sets the fields for which information is available within the scope of this library. Gathering and providing values for most of the fields is left to higher level applications that handle format specific data extraction. ISCC pydantic-model # ISCC Metadata Schema context : AnyUrl pydantic-field # JSON-LD Context URI type : AnyUrl pydantic-field # JSON Schema URI iscc : str pydantic-field required # ISCC in canonical encoding. name : str pydantic-field # The name or title of the intangible creation manifested by the identified digital asset description : str pydantic-field # Description of the digital asset identified by the ISCC (used as input for Meta-Code generation). Any user presentable text string (including Markdown text) indicative of the identity of the referent may be used. image : AnyUrl pydantic-field # URI for a user presentable image that serves as a preview of identified digital content or, in case of an NFT, the digital content itself. keywords : List [ str ] pydantic-field # List of keywords relevant to the identified digital content. identifier : Union [ str , List [ str ]] pydantic-field # Other identifier(s) such as those defined by ISO/TC 46/SC 9 referencing the work, product or other abstraction of which the referenced digital asset is a full or partial manifestation. filename : str pydantic-field # Filename of the referenced digital asset (automatically used as fallback if no seed_title element is specified) filesize : int pydantic-field # File size of media asset in bytes. mediatype : str pydantic-field # IANA Media Type (MIME type) tophash : str pydantic-field # Multihash hash over concatenation of metahash and datahash metahash : str pydantic-field # Multihash hash of metadata. datahash : str pydantic-field # Multihash hash of media file. duration : float pydantic-field # Duration of audio-visual media in secondes. fps : float pydantic-field # Frames per second of video assets. width : int pydantic-field # Width of visual media in pixels. height : int pydantic-field # Height of visual media in pixels. characters : int pydantic-field # Number of text characters (code points after Unicode normalization) language : Union [ str , List [ str ]] pydantic-field # Language(s) of content (BCP-47) in weighted order. parts : List [ str ] pydantic-field # Included Content-Codes. license : AnyUrl pydantic-field # URI of license for the identified digital content. redirect : HttpUrl pydantic-field # URL to which a resolver should redirect an ISCC-ID that has been minted from a declartion that includes the IPFS-hash of this metadata instance. dict ( self , * args , * , exclude_none = True , by_alias = True , ** kwargs ) # Exclude empty fields and support @context alias. Note This overides the default BaseModel.dict() dict_raw ( self ) # Exclude any versioned properties (used mostly for testing) json ( self , * args , * , exclude_none = True , by_alias = True , ** kwargs ) # Exclude empty fields and use @context alias. The by_alias=True allows us to generate valid JSON-LD by default. It translates our python \"context\" property to @context Note This overides the default BaseModel.json() code property readonly # Code without ISCC: -prefix code_obj property readonly # Wraps the iscc string property with a Code object. jcs ( self ) # Serialize metadata in conformance with JCS (RFC 8785) JSON canonicalization. Used as payload for cryptographic hashing. ipfs_hash ( self ) # Create canonical IPFS hash for ISCC metadata jsonld_context () classmethod # Build JSON-LD context from ISCC model for publishing Returns: Type Description str Serialized JSON-LD context for publishing.","title":"Schema"},{"location":"schema/schema/#iscc-schema","text":"Schema of objects returned by ISCC processing algorithms. The schemata define standard fields to be set by ISCC generating applications. This library only sets the fields for which information is available within the scope of this library. Gathering and providing values for most of the fields is left to higher level applications that handle format specific data extraction.","title":"ISCC - Schema"},{"location":"schema/schema/#iscc_core.schema.ISCC","text":"ISCC Metadata Schema","title":"ISCC"},{"location":"schema/schema/#iscc_core.schema.ISCC.context","text":"JSON-LD Context URI","title":"context"},{"location":"schema/schema/#iscc_core.schema.ISCC.type","text":"JSON Schema URI","title":"type"},{"location":"schema/schema/#iscc_core.schema.ISCC.iscc","text":"ISCC in canonical encoding.","title":"iscc"},{"location":"schema/schema/#iscc_core.schema.ISCC.name","text":"The name or title of the intangible creation manifested by the identified digital asset","title":"name"},{"location":"schema/schema/#iscc_core.schema.ISCC.description","text":"Description of the digital asset identified by the ISCC (used as input for Meta-Code generation). Any user presentable text string (including Markdown text) indicative of the identity of the referent may be used.","title":"description"},{"location":"schema/schema/#iscc_core.schema.ISCC.image","text":"URI for a user presentable image that serves as a preview of identified digital content or, in case of an NFT, the digital content itself.","title":"image"},{"location":"schema/schema/#iscc_core.schema.ISCC.keywords","text":"List of keywords relevant to the identified digital content.","title":"keywords"},{"location":"schema/schema/#iscc_core.schema.ISCC.identifier","text":"Other identifier(s) such as those defined by ISO/TC 46/SC 9 referencing the work, product or other abstraction of which the referenced digital asset is a full or partial manifestation.","title":"identifier"},{"location":"schema/schema/#iscc_core.schema.ISCC.filename","text":"Filename of the referenced digital asset (automatically used as fallback if no seed_title element is specified)","title":"filename"},{"location":"schema/schema/#iscc_core.schema.ISCC.filesize","text":"File size of media asset in bytes.","title":"filesize"},{"location":"schema/schema/#iscc_core.schema.ISCC.mediatype","text":"IANA Media Type (MIME type)","title":"mediatype"},{"location":"schema/schema/#iscc_core.schema.ISCC.tophash","text":"Multihash hash over concatenation of metahash and datahash","title":"tophash"},{"location":"schema/schema/#iscc_core.schema.ISCC.metahash","text":"Multihash hash of metadata.","title":"metahash"},{"location":"schema/schema/#iscc_core.schema.ISCC.datahash","text":"Multihash hash of media file.","title":"datahash"},{"location":"schema/schema/#iscc_core.schema.ISCC.duration","text":"Duration of audio-visual media in secondes.","title":"duration"},{"location":"schema/schema/#iscc_core.schema.ISCC.fps","text":"Frames per second of video assets.","title":"fps"},{"location":"schema/schema/#iscc_core.schema.ISCC.width","text":"Width of visual media in pixels.","title":"width"},{"location":"schema/schema/#iscc_core.schema.ISCC.height","text":"Height of visual media in pixels.","title":"height"},{"location":"schema/schema/#iscc_core.schema.ISCC.characters","text":"Number of text characters (code points after Unicode normalization)","title":"characters"},{"location":"schema/schema/#iscc_core.schema.ISCC.language","text":"Language(s) of content (BCP-47) in weighted order.","title":"language"},{"location":"schema/schema/#iscc_core.schema.ISCC.parts","text":"Included Content-Codes.","title":"parts"},{"location":"schema/schema/#iscc_core.schema.ISCC.license","text":"URI of license for the identified digital content.","title":"license"},{"location":"schema/schema/#iscc_core.schema.ISCC.redirect","text":"URL to which a resolver should redirect an ISCC-ID that has been minted from a declartion that includes the IPFS-hash of this metadata instance.","title":"redirect"},{"location":"schema/schema/#iscc_core.schema.ISCC.dict","text":"Exclude empty fields and support @context alias. Note This overides the default BaseModel.dict()","title":"dict()"},{"location":"schema/schema/#iscc_core.schema.ISCC.dict_raw","text":"Exclude any versioned properties (used mostly for testing)","title":"dict_raw()"},{"location":"schema/schema/#iscc_core.schema.ISCC.json","text":"Exclude empty fields and use @context alias. The by_alias=True allows us to generate valid JSON-LD by default. It translates our python \"context\" property to @context Note This overides the default BaseModel.json()","title":"json()"},{"location":"schema/schema/#iscc_core.schema.ISCC.code","text":"Code without ISCC: -prefix","title":"code"},{"location":"schema/schema/#iscc_core.schema.ISCC.code_obj","text":"Wraps the iscc string property with a Code object.","title":"code_obj"},{"location":"schema/schema/#iscc_core.schema.ISCC.jcs","text":"Serialize metadata in conformance with JCS (RFC 8785) JSON canonicalization. Used as payload for cryptographic hashing.","title":"jcs()"},{"location":"schema/schema/#iscc_core.schema.ISCC.ipfs_hash","text":"Create canonical IPFS hash for ISCC metadata","title":"ipfs_hash()"},{"location":"schema/schema/#iscc_core.schema.ISCC.jsonld_context","text":"Build JSON-LD context from ISCC model for publishing Returns: Type Description str Serialized JSON-LD context for publishing.","title":"jsonld_context()"},{"location":"utilities/utils/","text":"ISCC - Utilities # canonicalize ( obj ) # Canonical, deterministic serialization of ISCC metadata. We serialize ISCC metadata in a deterministic/reproducible manner by using JCS (RFC 8785) canonicalization. ipfs_hash ( stream ) # Create an IPFS hash for ISCC metadata. We use a specialized base16 encoded CIDv1 with sha3-224 and chunksize 1048576 as hashing algorithm for ISCC metadata. Example With IPFS v0.11.0 this equals to: $ipfs add --cid-version = 1 --chunker = size-1048576 --hash = sha3-224 <myfile> <my-cid> $ipfs cid format -b = base16 <my-cid> Note The rationale for this trickery is that we want to be able to use an IPFS hash as an ERC-721 / ERC-1155 uint256 _tokenID and also support ID substitution for the metadata URI. For details see discussion at OpenZeppelin Forum Learn more about IPFS CIDv1 at ProtoSchool Parameters: Name Type Description Default stream Stream Data to be hashed (currently max 1048576) required Returns: Type Description str A valid IPFS CIDv1 that can be used as token-id and metadata-uri sliding_window ( seq , width ) # Generate a sequence of equal \"width\" slices each advancing by one elemnt. All types that have a length and can be sliced are supported (list, tuple, str ...). The result type matches the type of the input sequence. Fragment slices smaller than the width at the end of the sequence are not produced. If \"witdh\" is smaller than the input sequence than one element will be returned that is shorter than the requested width. Parameters: Name Type Description Default seq Sequence Sequence of values to slide over required width int Width of sliding window in number of items required Returns: Type Description Union[Generat,] A generator of window sized items similarity ( a , b ) # Calculate similarity of ISCC codes as a percentage value (0-100). MainType, SubType, Version and Length of the codes must be the same. Parameters: Name Type Description Default a ISCC a required b ISCC b required Returns: Type Description int Similarity of ISCC a and b in percent (based on hamming distance) distance ( a , b ) # Calculate hamming distance of ISCC codes. MainType, SubType, Version and Length of the codes must be the same. Parameters: Name Type Description Default a ISCC a required b ISCC b required Returns: Type Description int Hamming distanced in number of bits. hamming_distance ( a , b ) # Calculate hamming distance for binary hash digests of equal length. Parameters: Name Type Description Default a bytes binary hash digest required b bytes binary hash digest required Returns: Type Description int Hamming distance in number of bits.","title":"Utilities"},{"location":"utilities/utils/#iscc-utilities","text":"","title":"ISCC - Utilities"},{"location":"utilities/utils/#iscc_core.utils.canonicalize","text":"Canonical, deterministic serialization of ISCC metadata. We serialize ISCC metadata in a deterministic/reproducible manner by using JCS (RFC 8785) canonicalization.","title":"canonicalize()"},{"location":"utilities/utils/#iscc_core.utils.ipfs_hash","text":"Create an IPFS hash for ISCC metadata. We use a specialized base16 encoded CIDv1 with sha3-224 and chunksize 1048576 as hashing algorithm for ISCC metadata. Example With IPFS v0.11.0 this equals to: $ipfs add --cid-version = 1 --chunker = size-1048576 --hash = sha3-224 <myfile> <my-cid> $ipfs cid format -b = base16 <my-cid> Note The rationale for this trickery is that we want to be able to use an IPFS hash as an ERC-721 / ERC-1155 uint256 _tokenID and also support ID substitution for the metadata URI. For details see discussion at OpenZeppelin Forum Learn more about IPFS CIDv1 at ProtoSchool Parameters: Name Type Description Default stream Stream Data to be hashed (currently max 1048576) required Returns: Type Description str A valid IPFS CIDv1 that can be used as token-id and metadata-uri","title":"ipfs_hash()"},{"location":"utilities/utils/#iscc_core.utils.sliding_window","text":"Generate a sequence of equal \"width\" slices each advancing by one elemnt. All types that have a length and can be sliced are supported (list, tuple, str ...). The result type matches the type of the input sequence. Fragment slices smaller than the width at the end of the sequence are not produced. If \"witdh\" is smaller than the input sequence than one element will be returned that is shorter than the requested width. Parameters: Name Type Description Default seq Sequence Sequence of values to slide over required width int Width of sliding window in number of items required Returns: Type Description Union[Generat,] A generator of window sized items","title":"sliding_window()"},{"location":"utilities/utils/#iscc_core.utils.similarity","text":"Calculate similarity of ISCC codes as a percentage value (0-100). MainType, SubType, Version and Length of the codes must be the same. Parameters: Name Type Description Default a ISCC a required b ISCC b required Returns: Type Description int Similarity of ISCC a and b in percent (based on hamming distance)","title":"similarity()"},{"location":"utilities/utils/#iscc_core.utils.distance","text":"Calculate hamming distance of ISCC codes. MainType, SubType, Version and Length of the codes must be the same. Parameters: Name Type Description Default a ISCC a required b ISCC b required Returns: Type Description int Hamming distanced in number of bits.","title":"distance()"},{"location":"utilities/utils/#iscc_core.utils.hamming_distance","text":"Calculate hamming distance for binary hash digests of equal length. Parameters: Name Type Description Default a bytes binary hash digest required b bytes binary hash digest required Returns: Type Description int Hamming distance in number of bits.","title":"hamming_distance()"}]}